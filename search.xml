<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[spring-cloud 服务发布与消费]]></title>
      <url>%2F2017%2F04%2F14%2Fspring-cloud%20%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83%E4%B8%8E%E6%B6%88%E8%B4%B9%2F</url>
      <content type="text"><![CDATA[Spring Cloud简介Spring Cloud是一个基于Spring Boot实现的云应用开发工具，它为基于JVM的云应用开发中的配置管理、服务发现、断路器、智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话和集群状态管理等操作提供了一种简单的开发方式。Spring Cloud包含了多个子项目（针对分布式系统中涉及的多个不同开源产品），比如：Spring Cloud Config、Spring Cloud Netflix、Spring Cloud CloudFoundry、Spring Cloud AWS、Spring Cloud Security、Spring Cloud Commons、Spring Cloud Zookeeper、Spring Cloud CLI等项目。 服务发布与消费创建服务注册中心创建一个基础的Spring Boot工程，这里命名为srpingcloud-eureka，并在pom.xml文件中添加以下依赖：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.3.5.RELEASE&lt;/version&gt; &lt;relativePath /&gt; &lt;/parent&gt; &lt;properties&gt; &lt;!-- spring-cloud版本号 --&gt; &lt;spring.cloud.version&gt;Brixton.SR5&lt;/spring.cloud.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;springcloud-eureka&lt;/finalName&gt; &lt;plugins&gt; &lt;!-- 设定maven所用jre版本避免maven update project时项目jre变为其它版本 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.7&lt;/source&gt; &lt;target&gt;1.7&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 启动一个服务注册中心，只需在Spring Boot的启动类中添加@EnableEurekaServer注解：1234567@EnableEurekaServer@SpringBootApplicationpublic class EurekaApplication &#123; public static void main(String[] args) &#123; new SpringApplicationBuilder(EurekaApplication.class).web(true).run(args); &#125;&#125; 默认情况下，该服务注册中心也会将自己作为客户端来注册它自己，所以需要禁用它的注册行为，只需要在application.properties中添加以下配置：1234server.port=1111eureka.client.register-with-eureka=falseeureka.client.fetch-registry=falseeureka.client.serviceUrl.defaultZone=http://localhost:$&#123;server.port&#125;/eureka/ 第二、第三行把默认注册行为设置为false，第四行设置注册中心的地址。启动工程后，访问：http://localhost:1111/ 可以看到目前还没有发现任何服务。 创建服务提供方创建一个提供服务的客户端，并向服务注册中心注册，即对外发布服务。假设我们有一个提供计算功能的微服务模块，通过传入两个参数a和b，计算a+b的结果并返回。首先，创建一个基础的Spring Boot工程，这里命名为srpingcloud-service，并在pom.xml文件中添加以下依赖：12345678910111213141516171819202122232425262728&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.3.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Brixton.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 其次，创建一个controller，简单实现/add接口：12345678@RestControllerpublic class ComputeController &#123; @RequestMapping(value = "/add" ,method = RequestMethod.GET) public Integer add(@RequestParam Integer a, @RequestParam Integer b) &#123; Integer r = a + b; return r; &#125;&#125; 要向注册中心注册服务，只需在启动类中添加@EnableDiscoveryClient注解：1234567@EnableDiscoveryClient@SpringBootApplicationpublic class ComputeServiceApplication &#123; public static void main(String[] args) &#123; new SpringApplicationBuilder(ComputeServiceApplication.class).web(true).run(args); &#125;&#125; 最后，需要配置微服务的名称和注册中心的地址：123spring.application.name=compute-serviceserver.port=2222eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka/ 通过spring.application.name属性，我们可以指定微服务的名称后续在调用的时候只需要使用该名称就可以进行服务的访问。eureka.client.serviceUrl.defaultZone属性对应服务注册中心的配置内容，指定服务注册中心的位置。启动该工程后，再次访问：http://localhost:1111/可以看到，COMPUTE-SERVICE的服务已经被注册了。 创建服务消费方Spring Cloud中有两种方式可以消费服务，Ribbon和Feign。 使用Ribbon实现消费者Ribbon是一个基于HTTP和TCP客户端的负载均衡器，可以在通过客户端中配置的ribbonServerList服务端列表去轮询访问以达到负载均衡的作用。当Ribbon与Eureka联合使用时，ribbonServerList会被DiscoverEnabledNIWSServerList重写，扩展成从Euraka注册中心中获取服务端列表，因此在Srping Cloud中，我们只需简单配置即可使用Ribbon消费服务。创建一个基础的Spring Boot工程，并在pom.xml文件中添加以下依赖： 123456789101112131415161718192021222324252627282930313233343536&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.3.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Brixton.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 在启动类中，通过@EnableDiscoveryClient注解来添加发现服务的能力。创建RestTemplate实例，并通过@LoadBalanced注解来开启负载均衡。 123456789101112@SpringBootApplication@EnableDiscoveryClientpublic class RibbonApplication &#123; @Bean @LoadBalanced RestTemplate restTemplate() &#123; return new RestTemplate(); &#125; public static void main(String[] args) &#123; SpringApplication.run(RibbonApplication.class, args); &#125;&#125; 创建ConsumerController来消费COMPUTE-SERVICE的add服务。通过注入RestTemplate来调用服务： 123456789@RestControllerpublic class ConsumerController &#123; @Autowired RestTemplate restTemplate; @RequestMapping(value = "/add", method = RequestMethod.GET) public String add() &#123; return restTemplate.getForEntity("http://COMPUTE-SERVICE/add?a=10&amp;b=20", String.class).getBody(); &#125;&#125; 最后，在application.properties中配置Eureka注册中心：123spring.application.name=ribbon-consumerserver.port=3333eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka/ 访问消费端的add接口，即可看到返回结果。 使用Feign实现消费者Feign是一个声明式的Web Service客户端，它使得编写Web Serivce客户端变得更加简单。我们只需要使用Feign来创建一个接口并用注解来配置它既可完成。它具备可插拔的注解支持，包括Feign注解和JAX-RS注解。Feign也支持可插拔的编码器和解码器。Spring Cloud为Feign增加了对Spring MVC注解的支持，还整合了Ribbon和Eureka来提供均衡负载的HTTP客户端实现。创建一个基础的Spring Boot工程，并在pom.xml文件中添加以下依赖：123456789101112131415161718192021222324252627282930313233343536&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.3.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Brixton.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 在启动类中通过@EnableFeignClients注解来开启Feign功能：12345678@SpringBootApplication@EnableDiscoveryClient@EnableFeignClientspublic class FeignApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(FeignApplication.class, args); &#125;&#125; 定义compute-service服务提供的接口：12345@FeignClient("compute-service")public interface ComputeClient &#123; @RequestMapping(method = RequestMethod.GET, value = "/add") Integer add(@RequestParam(value = "a") Integer a, @RequestParam(value = "b") Integer b);&#125; 使用@FeignClient(&quot;compute-service&quot;)注解来绑定该接口对应的服务； 通过Spring MVC的注解来配置服务的具体实现； 最后，在Controller中注入ComputeClient，即可消费服务：123456789@RestControllerpublic class ConsumerController &#123; @Autowired ComputeClient computeClient; @RequestMapping(value = "/add", method = RequestMethod.GET) public Integer add() &#123; return computeClient.add(10, 20); &#125;&#125; application.properties的配置与使用Ribbon时相同，指定Eureka注册中心即可。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[spring-boot 使用JavaConfig方式配置Dubbo]]></title>
      <url>%2F2017%2F04%2F14%2Fspring-boot%20%E4%BD%BF%E7%94%A8JavaConfig%E6%96%B9%E5%BC%8F%E9%85%8D%E7%BD%AEDubbo%2F</url>
      <content type="text"><![CDATA[Spring Boot提倡以JavaConfig的方式进行配置，就是使用注释来描述Bean配置的组件，从而取代让许多开发者诟病已久的xml配置方式。Spring Boot官方也提供了很多相关的JavaConfig例子，例如数据库配置，消息队列配置等。本文将提供一个JavaConfig配置Dubbo的例子。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import com.alibaba.dubbo.config.ApplicationConfig;import com.alibaba.dubbo.config.MonitorConfig;import com.alibaba.dubbo.config.ProtocolConfig;import com.alibaba.dubbo.config.ProviderConfig;import com.alibaba.dubbo.config.RegistryConfig;import com.alibaba.dubbo.config.spring.AnnotationBean;@Configurationpublic class DubboConfig &#123; // 应用名称 public static final String APPLICATION_NAME = "spring-boot-demo"; // 扫描service包路径 public static final String ANNOTATION_PACKAGE = "com.cipher.springboot.service"; // 以下信息将从配置文件application.properties中读取 @Value("$&#123;dubbo_registry_address&#125;") private String registryAddress; @Value("$&#123;dubbo_port&#125;") private int dubboPort; @Value("$&#123;dubbo_register&#125;") private boolean dubboRegister; /** * 提供方应用信息，用于计算依赖关系 * * @return */ @Bean public ApplicationConfig applicationConfig() &#123; ApplicationConfig applicationConfig = new ApplicationConfig(); applicationConfig.setName(APPLICATION_NAME); return applicationConfig; &#125; /** * 与&lt;dubbo:annotation/&gt;相当. * 提供方扫描带有@com.alibaba.dubbo.config.annotation. * Service的注解类 * * @return */ @Bean public static AnnotationBean annotationBean() &#123; AnnotationBean annotationBean = new AnnotationBean(); annotationBean.setPackage(ANNOTATION_PACKAGE); return annotationBean; &#125; /** * 使用zookeeper注册中心暴露服务地址 * * @return */ @Bean public RegistryConfig registryConfig() &#123; RegistryConfig registryConfig = new RegistryConfig(); registryConfig.setAddress(registryAddress); registryConfig.setRegister(dubboRegister); return registryConfig; &#125; /** * 用dubbo协议在指定端口暴露服务 * * @return */ @Bean public ProtocolConfig protocolConfig() &#123; ProtocolConfig protocolConfig = new ProtocolConfig("dubbo", dubboPort); // 默认为hessian2,但不支持无参构造函数类,而这种方式的效率很低 protocolConfig.setSerialization("java"); return protocolConfig; &#125; /** * 监控中心配置，protocol="registry"，表示从注册中心发现监控中心地址 * * @return */ @Bean public MonitorConfig monitorConfig() &#123; MonitorConfig monitorConfig = new MonitorConfig(); monitorConfig.setProtocol("registry"); return monitorConfig; &#125; /** * 当ProtocolConfig和ServiceConfig某属性没有配置时,采用此缺省值 * * @return */ @Bean public ProviderConfig providerConfig() &#123; ProviderConfig providerConfig = new ProviderConfig(); providerConfig.setTimeout(10000); providerConfig.setThreadpool("fixed"); providerConfig.setThreads(100); providerConfig.setAccepts(1000); return providerConfig; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[UML类图]]></title>
      <url>%2F2017%2F04%2F13%2FUML%E7%B1%BB%E5%9B%BE%2F</url>
      <content type="text"><![CDATA[依赖关系 123456public class Person &#123; public void doSomething()&#123; Card card = new Card();//局部变量 .... &#125; &#125; 12345public class Person &#123; public void doSomething(Card card)&#123;//方法参数 .... &#125; &#125; 123456public class Person &#123; public void doSomething()&#123; int id = Card.getId();//静态方法调用 ... &#125; &#125; 关联关系 1234567891011public class Person &#123; public Phone phone; public void setPhone(Phone phone)&#123; this.phone = phone; &#125; public Phone getPhone()&#123; return phone; &#125; &#125; 聚合关系 1234567public class Team &#123; public Person person; public Team(Person person)&#123; this.person = person; &#125; &#125; 组合关系 12345678910111213public class Person &#123; public Head head; public Body body; public Arm arm; public Leg leg; public Person()&#123; head = new Head(); body = new Body(); arm = new Arm(); leg = new Leg(); &#125; &#125; 继承关系]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《淘宝技术这十年》：武侠和倒立文化的起源]]></title>
      <url>%2F2017%2F04%2F13%2F%E3%80%8A%E6%B7%98%E5%AE%9D%E6%8A%80%E6%9C%AF%E8%BF%99%E5%8D%81%E5%B9%B4%E3%80%8B%EF%BC%9A%E6%AD%A6%E4%BE%A0%E5%92%8C%E5%80%92%E7%AB%8B%E6%96%87%E5%8C%96%E7%9A%84%E8%B5%B7%E6%BA%90%2F</url>
      <content type="text"><![CDATA[公司给这几个人租了房子，他们合住在湖畔花园旁边的小区里（男女分开），每天睁开眼就去公司，半夜两三点收工睡觉，响应用户的需求非常快。 这让我想起我第一份面试的工作，也是在一个封闭的小区里，租了一个套房当做公司。当时让我感觉就是吃睡都在那里，没日没夜的工作，但初出茅庐的我感觉这也是一个锻炼的机会，可是我最后没有选择它。现在想想，对于当时初入职场的我，在这种小公司也许能锻炼很多技术，但对于整个软件开发的规范模式、流程的认识不会有很好的帮助，也就不能从大体上去了解软件开发这个行业，我想这应该比较适合有一定经验的人去工作，也不知道他们招初级程序员的初衷是便宜劳动力，还是真的为了培养人才。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[IDEA中忽略spring配置文件无法识别xsd的错误]]></title>
      <url>%2F2017%2F04%2F12%2FIDEA%E4%B8%AD%E5%BF%BD%E7%95%A5spring%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%ABxsd%E7%9A%84%E9%94%99%E8%AF%AF%2F</url>
      <content type="text"><![CDATA[有时我们在写spring配置文件的时候，会出现idea无法识别schema，导致报错。虽然说不影响执行，但看着那红色的波浪线确实有一点不爽，寻思着能不能忽略这个错误。最开始的想法是像忽略代码语法校验那样，在Inspections中去掉相关的校验，但发现Inspections中没有schema，xsd等相关的配置，直到发现了如下的方法。 解决方法依次打开：Settings-&gt;Languages &amp; Frameworks-&gt;Schemas and DTDs把报错的xsd添加到忽略列表： 点击OK后会在忽略列表看到所加的地址： 世界又清静了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Dubbo服务提供者使用ProGuard实现代码混淆]]></title>
      <url>%2F2017%2F04%2F11%2FDubbo%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85%E4%BD%BF%E7%94%A8ProGuard%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86%2F</url>
      <content type="text"><![CDATA[ProGuard能够作为maven的插件使用，让我们在原来的项目结构中，能够方便的实现代码混淆。但是网上ProGuard的资料通常都是单应用的实现，因此本文基于dubbo分布式项目，简单描述一下如何实现服务提供者的代码混淆。 服务提供者代码混淆项目作为dubbo服务提供者，以jar的方式发布服务。 pom中添加ProGuard插件12345678910111213141516171819202122232425262728293031&lt;!-- ProGuard混淆插件--&gt;&lt;plugin&gt; &lt;groupId&gt;com.github.wvengen&lt;/groupId&gt; &lt;artifactId&gt;proguard-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.0.11&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;!-- 打包的时候混淆--&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;!-- 使用混淆功能--&gt; &lt;goal&gt;proguard&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;!-- 是否将生成的PG文件安装部署--&gt; &lt;attach&gt;true&lt;/attach&gt; &lt;!-- 是否混淆--&gt; &lt;obfuscate&gt;true&lt;/obfuscate&gt; &lt;!-- 指定生成文件分类 --&gt; &lt;attachArtifactClassifier&gt;pg&lt;/attachArtifactClassifier&gt; &lt;!-- 指定配置文件的路径，不在pom文件中配置，放在配置文件中方便管理 --&gt; &lt;proguardInclude&gt;$&#123;basedir&#125;/proguard.conf&lt;/proguardInclude&gt; &lt;!-- 添加依赖，添加jdk的依赖即可 --&gt; &lt;libs&gt; &lt;lib&gt;$&#123;java.home&#125;/lib/rt.jar&lt;/lib&gt; &lt;lib&gt;$&#123;java.home&#125;/lib/jce.jar&lt;/lib&gt; &lt;/libs&gt; &lt;/configuration&gt;&lt;/plugin&gt; pom同级目录下添加proguard.conf混淆配置文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# ----------------------------------# JDK目标版本# -----------------------------------target 1.7# ----------------------------------# 忽略所有告警# -----------------------------------ignorewarnings# ----------------------------------# 混淆时应用侵入式重载# -----------------------------------overloadaggressively# ----------------------------------# 优化时允许访问并修改有修饰符的类和类的成员# -----------------------------------allowaccessmodification# ----------------------------------#确定统一的混淆类的成员名称来增加混淆# -----------------------------------useuniqueclassmembernames# ----------------------------------# 不略过非公用类文件及成员# -----------------------------------dontskipnonpubliclibraryclasses-dontskipnonpubliclibraryclassmembers# ----------------------------------# 不输出通知# -----------------------------------dontnote# ----------------------------------# 不混淆所有包名，Spring配置中有大量固定写法的包名# -----------------------------------keeppackagenames# ----------------------------------# 不混淆所有特殊的类# -----------------------------------keepattributes SourceFile,Exceptions,InnerClasses,*Annotation*,Signature,LineNumberTable# ----------------------------------# 不混淆对外服务的类# 实体类、dao、service、枚举类：不混淆类名和属性、方法# 实现类：不混淆类名# -----------------------------------keep class xxx.dao.** &#123;*;&#125;-keep class xxx.domain.** &#123;*;&#125;-keep class xxx.enums.** &#123;*;&#125;-keep class xxx.service.** &#123;*;&#125;-keep class xxx.impl.**# ----------------------------------# 不混淆spring配置文件中定义的类# ----------------------------------按照项目配置 打包，并替换class文件经过以上配置后，执行maven打包命令mvn package，在项目的target文件夹中会得到两个jar：项目名.jar、项目名-pg.jar。然后我们要将这两个解压：12345PROJ=项目名PROJPG=$&#123;PROJ&#125;&quot;-pg&quot;unzip $PROJ.jar unzip $PROJPG.jar 并将“项目名-pg”文件夹中的cn目录拷贝到原项目中，然后把它打成jar包：123rm -rf $PROJ/cn/cp -avpf $PROJPG/cn/ $PROJ/jar cvfm $PROJPG.jar $PROJ/META-INF/MANIFEST.MF -C $PROJ/ . 此时得到的“项目名.jar”就是混淆后的可执行jar包。执行它即可发布服务到dubbo注册中心。以上操作可写成shell脚本，添加到自动部署流程中，实现自动化管理。 本文的配置请参照自身的项目做相应的调整]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[充值一波信仰]]></title>
      <url>%2F2017%2F04%2F11%2F%E5%85%85%E5%80%BC%E4%B8%80%E6%B3%A2%E4%BF%A1%E4%BB%B0%2F</url>
      <content type="text"><![CDATA[]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[spring-boot 集中处理异常]]></title>
      <url>%2F2017%2F04%2F10%2Fspring-boot%20%E9%9B%86%E4%B8%AD%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%2F</url>
      <content type="text"><![CDATA[spring-boot配置方式集中处理异常，统一规范接口对外的异常输出。业务代码只需往外抛异常，不需过多关注异常的输出形式。 非系统抛出异常对于400，404等非系统抛出的异常，使用以下方式： 123456789101112131415161718@Configurationpublic class ErrorHandler &#123; @Bean public EmbeddedServletContainerCustomizer containerCustomizer() &#123; return new MyCustomizer(); &#125; private static class MyCustomizer implements EmbeddedServletContainerCustomizer &#123; @Override public void customize(ConfigurableEmbeddedServletContainer container) &#123; container.addErrorPages(new ErrorPage(HttpStatus.BAD_REQUEST, "/400")); container.addErrorPages(new ErrorPage(HttpStatus.NOT_FOUND, "/404")); &#125; &#125;&#125; 对于状态码为400，404的响应会转到相应的请求/400，/404中处理。 系统抛出异常对于系统抛出的异常，除了跳到错误页面之外，我们常常需要记录错误日志等信息，因此不使用上述方法。而是在处理类和方法上加上注解@ControllerAdvice，@ExceptionHandler，如下：1234567891011121314151617@Controller@ControllerAdvicepublic class ErrorController &#123; @RequestMapping(value = &#123; "/404" &#125;) @ResponseBody public String notFound() &#123; return "404"; &#125; @ExceptionHandler(Exception.class) @ResponseBody public String handleException(Exception e) &#123; // 记录错误日志 return "Exception"; &#125;&#125; 在此类中一并处理非系统抛出异常，如上述的/404请求。 参考：Spring Boot Reference Guide，Spring Framework Reference Documentation -END-]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[sonar质量分析 Tabulation characters should not be used 原因与解决]]></title>
      <url>%2F2017%2F04%2F10%2Fsonar%E8%B4%A8%E9%87%8F%E5%88%86%E6%9E%90%20Tabulation%20characters%20should%20not%20be%20used%20%E5%8E%9F%E5%9B%A0%E4%B8%8E%E8%A7%A3%E5%86%B3%2F</url>
      <content type="text"><![CDATA[缘由项目中使用sonar质量分析，很多代码提示：Replace all tab characters in this file by sequences of white-spaces. Tabulation characters should not be usedDevelopers should not need to configure the tab width of their text editors in order to be able to read source code. So the use of tabulation character must be banned. 这是因为编辑器不一样默认的tab的宽度或在不同系统下显示的效果不同，考虑到代码跨平台的可读性，应该将tab统一换成空格。 解决将编辑器中的tab换成空格，以Eclipse为例。 设置Eclipse中的tab键为4个空格第一步点击 window-&gt;preference-,依次选择 General-&gt;Editors-&gt;Text Editors,选中右侧的 insert space for tabs;如下图所示，保存，第一步完成； 第二步点击 window-&gt;preference-,依次选择 java（或C++）-&gt;code style -&gt;formatter,点击右侧的editor，选则左侧 tab policy的值为spaces only,确定，应用保存即可，如下图所示： 若出现应用Apply按钮为灰色的情况，需要回到上一步，点击new按钮，根据当前的样式重新生成一个新的样式并保存，重复第二步，编辑该样式即可，如下图： 注意编辑完要选择新建的这个样式。 参考：sonar质量分析不让用tab，说要使用空格，大家怎么看？，设置Eclipse中的tab键为4个空格的完整方法 -END-]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Maven初探]]></title>
      <url>%2F2017%2F04%2F10%2FMaven%E5%88%9D%E6%8E%A2%2F</url>
      <content type="text"><![CDATA[最近刚接触了Maven，就根据自己的理解介绍一下Maven在开发中怎么用，顺便巩固一下知识。 Maven是什么我目前使用Maven主要是管理项目中jar包，其它高级的用法暂时还没涉及到。我们为什么要用Maven帮我们管理jar包呢，一个是我们不需要自己再到各个第三方框架或技术的网站上下载jar包了，另外一个是很好的统一了项目中各jar包的版本，因为多人开发中使用不同版本的jar包可能会有版本的冲突问题。Maven提供一个中央仓库，里面有几乎所有主流技术的jar包，我们只需要在配置文件中指定好要使用的jar，Maven就会帮我们自动下载。Maven会在本地建一个仓库，第一次下载的jar包放在本地仓库里，Maven根据配置注入jar的时候先从本地仓库里查找，如果没有再从远程中央仓库里下载，提高了效率。 如何安装和配置Maven安装Maven跟安装Jdk差不多，我们只需要把Maven下载下来，在环境变量中新建一个变量%MAVEN_HOME%，再在path中加上%MAVEN_HOME%/bin，如此，我们就能在控制台中使用Maven的命令了，我们可以在控制台输入mvn -v，如果成功输入Maven的版本信息，就说明Maven已经能正常工作了。但是，在使用之前我们做一些简单的修改来更好的使用Maven。 一些必要的修改首先，在Maven根目录下进入conf文件夹找到settings.xml配置文件，它可以配置Maven各种信息。在文件里面找到&lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;，这一行是配置Maven本地仓库的路径，把标签中的路径换成自己指定的路径例如E:\apache-maven-3.2.3-bin\Repository，要在对应的地方把这个文件夹新建好，这样Maven下载下来的jar包就会存到这个文件夹中。注意这一行在文件中是注释掉的，要把注释打开。接着，在配置文件中找到&lt;proxies&gt;标签，这里是设置Maven的镜像，如果我们有自己局域网内的中央仓库，可以在这里设置，这样Maven就会从我们局域网中的仓库下载，速度就会快很多。在日常开发中主要是设置这两个地方。 在Eclipse中集成Maven安装Maven插件我使用的是Eclipse版本是kepler，首先要安装Maven插件，在菜单栏中选择Help——Install New Software…接着你会看到一个Install对话框，点击Work with:字段边上的Add按钮，你会得到一个新的Add Repository对话框，在Name字段中输入m2e，Location字段中输入在线安装地址，这里提供一个地址，如果失效了可以在网上再找。然后点击OK。Eclipse会下载m2eclipse安装站点上的资源信息。 加入本地Maven依次选择菜单Windows——Preferences——Maven——Installations，然后在界面中点击Add，选择本地Maven的根目录，这样我们就设置好Maven插件了。 Eclipse创建Maven项目新建项目选择Maven Project，勾选Use default Workspace location使用默认的Workspace路径，点Next，一般的Web项目我们选择webapp点Next，输入工程信息， Group Id类似一个包名，Artifact Id类似类名。其它默认即可。点Finish就完成创建了。完成后我们能在项目中找到一个pom.xml文件，里面就可以配置我们项目中所需的依赖jar包了。 最后以上就是我最近初学Maven的一点认识，Maven确实是一个很好的构建工具，而也不仅仅是一个构建工具。更深的了解还要在以后的学习当中去探索。-END-]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mybatis分页方案]]></title>
      <url>%2F2017%2F04%2F10%2FMybatis%E5%88%86%E9%A1%B5%E6%96%B9%E6%A1%88%2F</url>
      <content type="text"><![CDATA[概述项目开发中经常需要分页，但为了提高开发效率，开发过程中往往不考虑分页。那么如何在功能开发完后使用一种对代码侵略度最低的方式实现分页，本文将提供一种方案。 参考： Mybatis极其(最)简(好)单(用)的一个分页插件 Mybatis分页插件 - PageHelper 1. 简单使用1.1 引入分页插件添加如下maven依赖： 12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;3.6.3&lt;/version&gt;&lt;/dependency&gt; 1.2 配置Mybatis拦截器插件（以下两种方式选一种即可）1.2.1 在Mybatis配置文件中配置1234567891011121314151617181920212223242526272829303132&lt;!-- plugins在配置文件中的位置必须符合要求，否则会报错，顺序如下: properties?, settings?, typeAliases?, typeHandlers?, objectFactory?,objectWrapperFactory?, plugins?, environments?, databaseIdProvider?, mappers?--&gt;&lt;plugins&gt; &lt;!-- com.github.pagehelper为PageHelper类所在包名 --&gt; &lt;plugin interceptor="com.github.pagehelper.PageHelper"&gt; &lt;property name="dialect" value="mysql"/&gt; &lt;!-- 该参数默认为false --&gt; &lt;!-- 设置为true时，会将RowBounds第一个参数offset当成pageNum页码使用 --&gt; &lt;!-- 和startPage中的pageNum效果一样--&gt; &lt;property name="offsetAsPageNum" value="true"/&gt; &lt;!-- 该参数默认为false --&gt; &lt;!-- 设置为true时，使用RowBounds分页会进行count查询 --&gt; &lt;property name="rowBoundsWithCount" value="true"/&gt; &lt;!-- 设置为true时，如果pageSize=0或者RowBounds.limit = 0就会查询出全部的结果 --&gt; &lt;!-- （相当于没有执行分页查询，但是返回结果仍然是Page类型）--&gt; &lt;property name="pageSizeZero" value="true"/&gt; &lt;!-- 3.3.0版本可用 - 分页参数合理化，默认false禁用 --&gt; &lt;!-- 启用合理化时，如果pageNum&lt;1会查询第一页，如果pageNum&gt;pages会查询最后一页 --&gt; &lt;!-- 禁用合理化时，如果pageNum&lt;1或pageNum&gt;pages会返回空数据 --&gt; &lt;property name="reasonable" value="true"/&gt; &lt;!-- 3.5.0版本可用 - 为了支持startPage(Object params)方法 --&gt; &lt;!-- 增加了一个`params`参数来配置参数映射，用于从Map或ServletRequest中取值 --&gt; &lt;!-- 可以配置pageNum,pageSize,count,pageSizeZero,reasonable,不配置映射的用默认值 --&gt; &lt;property name="params" value="pageNum=start;pageSize=limit;pageSizeZero=zero;reasonable=heli;count=contsql"/&gt; &lt;/plugin&gt;&lt;/plugins&gt; 1.2.2 在spring配置文件中配置1234567891011121314151617181920&lt;!-- 定义SqlSessionFactoryBean --&gt;&lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 指定连接资源 --&gt; &lt;property name="dataSource" ref="druidDataSource" /&gt; &lt;!-- 指定映射文件 --&gt; &lt;property name="mapperLocations" value="classpath*:mapper/*.xml" /&gt; &lt;!-- 配置分页插件 --&gt; &lt;property name="plugins"&gt; &lt;array&gt; &lt;bean class="com.github.pagehelper.PageHelper"&gt; &lt;property name="properties"&gt; &lt;value&gt; dialect=mysql reasonable=true &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/array&gt; &lt;/property&gt;&lt;/bean&gt; 1.2 在代码中使用在你需要进行分页的Mybatis方法前调用PageHelper.startPage静态方法即可，紧跟在这个方法后的第一个Mybatis查询方法会被进行分页。 12345// startPage(第几页, 多少条数据)PageHelper.startPage(currentPage, Constant.PERPAGE_SIZE);List&lt;OperationVO&gt; resultList = operationService.queryOperations(operationVO);//用PageInfo对结果进行包装PageInfo pageInfo = new PageInfo(resultList); 如此，就能获取指定页数和数量的数据（resultList）。 PageInfo包含了非常全面的分页属性 123456789101112131415161718192021222324252627282930313233343536373839404142public class PageInfo&lt;T&gt; implements Serializable &#123; private static final long serialVersionUID = 1L; //当前页 private int pageNum; //每页的数量 private int pageSize; //当前页的数量 private int size; //由于startRow和endRow不常用，这里说个具体的用法 //可以在页面中"显示startRow到endRow 共size条数据" //当前页面第一个元素在数据库中的行号 private int startRow; //当前页面最后一个元素在数据库中的行号 private int endRow; //总记录数 private long total; //总页数 private int pages; //结果集 private List&lt;T&gt; list; //第一页 private int firstPage; //前一页 private int prePage; //下一页 private int nextPage; //最后一页 private int lastPage; //是否为第一页 private boolean isFirstPage = false; //是否为最后一页 private boolean isLastPage = false; //是否有前一页 private boolean hasPreviousPage = false; //是否有下一页 private boolean hasNextPage = false; //导航页码数 private int navigatePages; //所有导航页号 private int[] navigatepageNums; ...&#125; 可根据这些信息发送到前端实现前端分页。 2. 结合前端jquery.DataTable插件实现前端分页DataTable插件的详细使用方法请参考各搜索引擎或dataTables-使用详细说明整理 为了结合DataTable插件，需要传递一些特定的参数，为此封装了两个类。请参考(essa内网)： DataTableVO DataTableUtil 2.1 前端代码示例12345678910111213141516171819202122232425262728293031323334353637383940414243resultDataTable = $("#" + tableId).dataTable(&#123; "aLengthMenu" : [ [ 5, 10, 20 ], [ 5, 10, 20 ] ], "iDisplayLength" : 5, "bProcessing" : true, "bServerSide" : true, // 指定后台对应的url "sAjaxSource" : rootPath + "/log/getTableData.do", // 指定列的值，mData与后台返回的属性名一致 "aoColumns" : [ &#123; "mData" : "updateUserName", "sClass" : "hidden-480 center" &#125;, &#123; "mData" : "objectName", "sClass" : "hidden-480 center" &#125;, &#123; "mData" : "objectId", "sClass" : "hidden-480 center" &#125;, &#123; "mData" : "olderValue", "sClass" : "hidden-480" &#125;, &#123; "mData" : "newValue", "sClass" : "hidden-480" &#125; ], // ajax发送请求参数到后台，aaData必须包含，也可以增加自定义参数 "fnServerData" : function(sSource, aaData, fnCallback) &#123; $.ajax(&#123; "type" : "post", "url" : sSource, "dataType" : "json", "data" : &#123; aaData : JSON.stringify(aaData)， // 自定义参数，如搜索条件 custom : custom &#125;, "success" : function(resp) &#123; fnCallback(resp); &#125; &#125;); &#125;, "sPaginationType" : "bootstrap" &#125;); 2.2 后端代码示例12345678910111213141516 @RequestMapping("/getTableData.do")@ResponseBodypublic Map&lt;String, Object&gt; getTableData(String aaData, HistoryVO historyVO) &#123; // 接收DataTable插件传递的aaData，封装成DataTableVO DataTableVO&lt;HistoryVO&gt; table = DataTableUtil.getDataTableVO(aaData); // 开始分页 PageHelper.startPage(table.getPageIndex(), table.getiDisplayLength()); List&lt;HistoryVO&gt; resultList = historyService.queryHistory(historyVO); PageInfo pageInfo = new PageInfo(resultList); // 根据分页结果设置table参数 table.setiTotalRecords(pageInfo.getTotal()); table.setAaData(resultList); // 返回DataTable相应的json数据 Map&lt;String, Object&gt; dataMap = DataTableUtil.getReturnMap(table); return dataMap;&#125; 通过上述示例方法返回json数据到前台，DataTable接收显示分页数据。 3. 使用EL表达式实现前端分页的一个示例 后台发送pageInfo到前台 1model.addAttribute("page", pageInfo); 前台使用EL表达式实现分页，pageInfo中的各项参数请参考1.2节 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;div class="row-fluid"&gt; &lt;div class="span6"&gt; &lt;div id="user_group_table_info" class="dataTables_info" role="status" aria-live="polite"&gt;显示第 $&#123;page.startRow&#125; - $&#123;page.endRow&#125; 条数据; 共有$&#123;page.total&#125; 条记录&lt;/div&gt; &lt;/div&gt; &lt;div class="span6"&gt; &lt;div id="role_group_table_paginate" class="dataTables_paginate paging_bootstrap pagination"&gt; &lt;ul&gt; &lt;c:choose&gt; &lt;c:when test="$&#123;page.isFirstPage&#125;"&gt; &lt;li class="prev disabled"&gt;&lt;a href="#"&gt; ← &lt;span class="hidden-480"&gt;上一页&lt;/span&gt; &lt;/a&gt;&lt;/li&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; &lt;li class="prev"&gt;&lt;a href="$&#123;currentPath&#125;?pageNum=$&#123;page.prePage&#125;"&gt; ← &lt;span class="hidden-480"&gt;上一页&lt;/span&gt; &lt;/a&gt;&lt;/li&gt; &lt;/c:otherwise&gt; &lt;/c:choose&gt; &lt;c:forEach begin="1" end="$&#123;page.pages&#125;" var="p"&gt; &lt;c:choose&gt; &lt;c:when test="$&#123;p == page.pageNum&#125;"&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;$&#123;p&#125;&lt;/a&gt;&lt;/li&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; &lt;li class=""&gt;&lt;a href="$&#123;currentPath&#125;?pageNum=$&#123;p&#125;"&gt;$&#123;p&#125;&lt;/a&gt;&lt;/li&gt; &lt;/c:otherwise&gt; &lt;/c:choose&gt; &lt;/c:forEach&gt; &lt;c:choose&gt; &lt;c:when test="$&#123;page.isLastPage&#125;"&gt; &lt;li class="next disabled"&gt;&lt;a href="#"&gt;&lt;span class="hidden-480"&gt;下一页&lt;/span&gt; → &lt;/a&gt;&lt;/li&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; &lt;li class="next"&gt;&lt;a href="$&#123;currentPath&#125;?pageNum=$&#123;page.nextPage&#125;"&gt; &lt;span class="hidden-480"&gt;下一页&lt;/span&gt; → &lt;/a&gt;&lt;/li&gt; &lt;/c:otherwise&gt; &lt;/c:choose&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 总结在使用此Mybatis分页插件时，不需要在分页的地方手写分页sql和count的sql，不需要更改已有的业务代码，只需要在执行sql前调用一句代码，即可实现分页，并得到丰富的分页信息。有了这些分页信息，前端可以选用多种分页方法，非常方便。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[spring-boot 实现文件上传]]></title>
      <url>%2F2017%2F04%2F10%2Fspring-boot%20%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%2F</url>
      <content type="text"><![CDATA[错误信息: Corrupt form data: premature ending最近要实现文件上传功能，需要使用O’Reilly公司的cos上传组件，但是这个组件太过久远，最近更新是08年，早期的spring版本支持，现在已经不支持了，好在它是开源的，我根据spring早期版本里的源码自己实现了。但是出现了错误：Corrupt form data: premature ending，网上找到很多都是struts上的错误，原因是request被过滤了，cos只能接受HttpServletRequest，但在spring-boot中也有这个问题，spring-boot虽然节省了我们很多的配置工作，但也无形中为我们做了很多可能我们不需要的配置。 声明MultipartResolverspring默认支持两种上传方式，一个是基于Servlet3.0的StandardServletMultipartResolver，一个是基于commons的CommonsMultipartResolver。在spring-boot中，会默认帮我们声明StandardServletMultipartResolver，要想更改成commons，需要在spring-boot中包含主函数的类中修改成如下代码：123456789101112131415161718@Configuration//exclude表示自动配置时不包括Multipart配置@EnableAutoConfiguration(exclude=&#123;MultipartAutoConfiguration.class&#125;)@ComponentScan("com.essa")public class UploadApplication extends WebMvcConfigurerAdapter &#123; public static void main(String[] args) &#123; SpringApplication.run(UploadApplication.class, args); &#125; //显式声明CommonsMultipartResolver为mutipartResolver @Bean(name="multipartResolver") public MultipartResolver mutipartResolver() &#123; CommonsMultipartResolver com = new CommonsMultipartResolver(); com.setDefaultEncoding("utf-8"); return com; &#125;&#125; 使用MultipartResolver若表单的提交方式为multipart/form-data，spring会将request根据声明的mutipartResolver转换为对应的MultipartHttpServletRequest，我们也可以在代码中这样做：1MultipartHttpServletRequest mRequest = (MultipartHttpServletRequest) request; 如此，我们就能使用mRequest得到上传文件：123MultipartFile getFile(String name); 或List&lt;MultipartFile&gt; getFiles(String name); 或Map&lt;String, MultipartFile&gt; getFileMap(); 得到的类型为MultipartFile，里面封装了File的各种信息。 3. 最后综上，作为spring的新项目，spring-boot还是很人性化的，只是我现在还没研究透它，它确实为项目开发提供了更加快速简洁的方法。 -END-]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[spring-boot 替换内嵌tomcat版本]]></title>
      <url>%2F2017%2F04%2F10%2Fspring-boot%20%E6%9B%BF%E6%8D%A2%E5%86%85%E5%B5%8Ctomcat%E7%89%88%E6%9C%AC%2F</url>
      <content type="text"><![CDATA[spring-boot中的内嵌tomcat有默认的指定版本，若想修改为其他版本，有以下两种途径： 使用parent的方式若引入spring-boot的方式为加入&lt;parent&gt;：123456&lt;!-- Inherit defaults from Spring Boot --&gt;&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.3.0.BUILD-SNAPSHOT&lt;/version&gt;&lt;/parent&gt; 则只需在properties中指定tomcat版本即可：123&lt;properties&gt; &lt;tomcat.version&gt;7.0.59&lt;/tomcat.version&gt;&lt;/properties&gt; 这种方式比较简单，官方文档中也有说明 使用dependencyManagement的方式有时我们的项目中有自己的parent，则需要使用&lt;dependencyManagement&gt;的方式引入spring-boot：12345678910111213141516&lt;properties&gt; &lt;tomcat.version&gt;7.0.59&lt;/tomcat.version&gt;&lt;/properties&gt;...&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;!-- Import dependency management from Spring Boot --&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;1.3.0.BUILD-SNAPSHOT&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 此时修改内嵌tomcat的版本则需要在&lt;dependencyManagement&gt;中加入内嵌tomcat的所有依赖，以替换默认的tomcat：12345678910111213141516171819202122232425262728293031323334353637383940&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- 替换spring-boot内嵌tomcat --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-core&lt;/artifactId&gt; &lt;version&gt;$&#123;tomcat.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-el&lt;/artifactId&gt; &lt;version&gt;$&#123;tomcat.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-logging-juli&lt;/artifactId&gt; &lt;version&gt;$&#123;tomcat.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;version&gt;$&#123;tomcat.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-websocket&lt;/artifactId&gt; &lt;version&gt;$&#123;tomcat.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;tomcat.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-jsp-api&lt;/artifactId&gt; &lt;version&gt;$&#123;tomcat.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 这种方式比较麻烦，但在不能引入parent和需要修改tomcat版本的情况下，也是无赖之举。 参考How to use Tomcat 8 + Spring Boot + Maven -END-]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mybatis整合redis实现缓存]]></title>
      <url>%2F2017%2F04%2F10%2FMybatis%E6%95%B4%E5%90%88redis%E5%AE%9E%E7%8E%B0%E7%BC%93%E5%AD%98%2F</url>
      <content type="text"><![CDATA[概述Mybatis默认缓存是PerpetualCache，它实现了Cache接口。Mybatis为了方便我们扩展缓存定义了一个Cache接口，因此，我们只需要参考源码自己使用redis实现Cache接口，即可达到Mybatis整合redis管理缓存的目的。 开始本文介绍在spring-mvc的项目中，如何实现使用redis作为Mybatis的二级缓存。重点是实现Cache接口，而如何引入redis有多种方式，本文使用其中一种。 环境 jdk：1.7 redis：2.8.12 spring：4.1.1.RELEASE 新建redis.properties文件用于记录redis的基本信息1234567891011# ====================================================# redis settings# ====================================================redis.host=127.0.0.1redis.port=6379redis.pass=redis.maxIdle=300redis.maxActive=600redis.maxWait=1000redis.testOnBorrow=false 新建RedisConfig.java类用于获取redis配置信息12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class RedisConfig &#123; private static String host; private static String port; private static String pass; private static String maxIdle; private static String maxActive; private static String maxWait; private static String testOnBorrow; public RedisConfig(String host, String port, String pass, String maxIdle, String maxActive, String maxWait, String testOnBorrow) &#123; super(); RedisConfig.host = host; RedisConfig.port = port; RedisConfig.pass = pass; RedisConfig.maxIdle = maxIdle; RedisConfig.maxActive = maxActive; RedisConfig.maxWait = maxWait; RedisConfig.testOnBorrow = testOnBorrow; &#125; public static String getHost() &#123; return host; &#125; public static String getPort() &#123; return port; &#125; public static String getPass() &#123; return pass; &#125; public static String getMaxIdle() &#123; return maxIdle; &#125; public static String getMaxActive() &#123; return maxActive; &#125; public static String getMaxWait() &#123; return maxWait; &#125; public static String getTestOnBorrow() &#123; return testOnBorrow; &#125; public void setHost(String host) &#123; RedisConfig.host = host; &#125; public void setPort(String port) &#123; RedisConfig.port = port; &#125; public void setPass(String pass) &#123; RedisConfig.pass = pass; &#125; public void setMaxIdle(String maxIdle) &#123; RedisConfig.maxIdle = maxIdle; &#125; public void setMaxActive(String maxActive) &#123; RedisConfig.maxActive = maxActive; &#125; public void setMaxWait(String maxWait) &#123; RedisConfig.maxWait = maxWait; &#125; public void setTestOnBorrow(String testOnBorrow) &#123; RedisConfig.testOnBorrow = testOnBorrow; &#125;&#125; spring配置文件中构造RedisConfig123456789101112131415161718192021222324252627&lt;context:property-placeholder location="classpath:redis.properties" ignore-unresolvable="true" ignore-resource-not-found="true" /&gt;&lt;bean id="redisConfig" class="cn.essa.component.privilege.util.RedisConfig"&gt; &lt;constructor-arg index="0"&gt; &lt;value&gt;$&#123;redis.host&#125;&lt;/value&gt; &lt;/constructor-arg&gt; &lt;constructor-arg index="1"&gt; &lt;value&gt;$&#123;redis.port&#125;&lt;/value&gt; &lt;/constructor-arg&gt; &lt;constructor-arg index="2"&gt; &lt;value&gt;$&#123;redis.pass&#125;&lt;/value&gt; &lt;/constructor-arg&gt; &lt;constructor-arg index="3"&gt; &lt;value&gt;$&#123;redis.maxIdle&#125;&lt;/value&gt; &lt;/constructor-arg&gt; &lt;constructor-arg index="4"&gt; &lt;value&gt;$&#123;redis.maxActive&#125;&lt;/value&gt; &lt;/constructor-arg&gt; &lt;constructor-arg index="5"&gt; &lt;value&gt;$&#123;redis.maxWait&#125;&lt;/value&gt; &lt;/constructor-arg&gt; &lt;constructor-arg index="6"&gt; &lt;value&gt;$&#123;redis.testOnBorrow&#125;&lt;/value&gt; &lt;/constructor-arg&gt;&lt;/bean&gt; 如此即可在普通类中使用RedisConfig，得到redis配置信息 新建RedisCache.java类该类实现了org.apache.ibatis.cache.Cache接口123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263/** * @ClassName: RedisCache * @Description: 使用第三方缓存服务器redis，处理二级缓存 * @author cipher * */public class RedisCache implements Cache &#123; private static final Log LOG = LogFactory.getLog(RedisCache.class); /** The ReadWriteLock. */ private final ReadWriteLock readWriteLock = new ReentrantReadWriteLock(); private String id; public RedisCache(final String id) &#123; if (id == null) &#123; throw new IllegalArgumentException("必须传入ID"); &#125; LOG.debug("&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;MybatisRedisCache:id=" + id); this.id = id; &#125; @Override public String getId() &#123; return this.id; &#125; @Override public int getSize() &#123; Jedis jedis = null; JedisPool jedisPool = null; int result = 0; boolean borrowOrOprSuccess = true; try &#123; jedis = CachePool.getInstance().getJedis(); jedisPool = CachePool.getInstance().getJedisPool(); result = Integer.valueOf(jedis.dbSize().toString()); &#125; catch (JedisConnectionException e) &#123; LOG.error(e); borrowOrOprSuccess = false; if (jedis != null) &#123; jedisPool.returnBrokenResource(jedis); &#125; &#125; finally &#123; if (borrowOrOprSuccess) &#123; jedisPool.returnResource(jedis); &#125; &#125; return result; &#125; @Override public void putObject(Object key, Object value) &#123; if (LOG.isDebugEnabled()) &#123; LOG.debug("&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;putObject:" + key.hashCode() + "=" + value); &#125; if (LOG.isInfoEnabled()) &#123; LOG.info("&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;put to redis sql :" + key.toString()); &#125; Jedis jedis = null; JedisPool jedisPool = null; boolean borrowOrOprSuccess = true; try &#123; jedis = CachePool.getInstance().getJedis(); jedisPool = CachePool.getInstance().getJedisPool(); jedis.set(SerializeUtil.serialize(key.hashCode()), SerializeUtil.serialize(value)); &#125; catch (JedisConnectionException e) &#123; LOG.error(e); borrowOrOprSuccess = false; if (jedis != null) &#123; jedisPool.returnBrokenResource(jedis); &#125; &#125; finally &#123; if (borrowOrOprSuccess) &#123; jedisPool.returnResource(jedis); &#125; &#125; &#125; @Override public Object getObject(Object key) &#123; Jedis jedis = null; JedisPool jedisPool = null; Object value = null; boolean borrowOrOprSuccess = true; try &#123; jedis = CachePool.getInstance().getJedis(); jedisPool = CachePool.getInstance().getJedisPool(); value = SerializeUtil.unserialize(jedis.get(SerializeUtil .serialize(key.hashCode()))); &#125; catch (JedisConnectionException e) &#123; LOG.error(e); borrowOrOprSuccess = false; if (jedis != null) &#123; jedisPool.returnBrokenResource(jedis); &#125; &#125; finally &#123; if (borrowOrOprSuccess) &#123; jedisPool.returnResource(jedis); &#125; &#125; if (LOG.isDebugEnabled()) &#123; LOG.debug("&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;getObject:" + key.hashCode() + "=" + value); &#125; return value; &#125; @Override public Object removeObject(Object key) &#123; Jedis jedis = null; JedisPool jedisPool = null; Object value = null; boolean borrowOrOprSuccess = true; try &#123; jedis = CachePool.getInstance().getJedis(); jedisPool = CachePool.getInstance().getJedisPool(); value = jedis.expire(SerializeUtil.serialize(key.hashCode()), 0); &#125; catch (JedisConnectionException e) &#123; LOG.error(e); borrowOrOprSuccess = false; if (jedis != null) &#123; jedisPool.returnBrokenResource(jedis); &#125; &#125; finally &#123; if (borrowOrOprSuccess) &#123; jedisPool.returnResource(jedis); &#125; &#125; if (LOG.isDebugEnabled()) &#123; LOG.debug("&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;removeObject:" + key.hashCode() + "=" + value); &#125; return value; &#125; @Override public void clear() &#123; Jedis jedis = null; JedisPool jedisPool = null; boolean borrowOrOprSuccess = true; try &#123; jedis = CachePool.getInstance().getJedis(); jedisPool = CachePool.getInstance().getJedisPool(); jedis.flushDB(); jedis.flushAll(); &#125; catch (JedisConnectionException e) &#123; LOG.error(e); borrowOrOprSuccess = false; if (jedis != null) &#123; jedisPool.returnBrokenResource(jedis); &#125; &#125; finally &#123; if (borrowOrOprSuccess) &#123; jedisPool.returnResource(jedis); &#125; &#125; &#125; @Override public ReadWriteLock getReadWriteLock() &#123; return readWriteLock; &#125; /** * * @ClassName: CachePool * @Description: 单例Cache池 * */ public static class CachePool &#123; JedisPool pool; private static final CachePool CACHEPOOL = new CachePool(); public static CachePool getInstance() &#123; return CACHEPOOL; &#125; private CachePool() &#123; try &#123; int maxIdle = Integer .valueOf(RedisConfig.getMaxIdle()); long maxWait = Long.valueOf(RedisConfig.getMaxWait()); int maxActive = Integer.valueOf(RedisConfig.getMaxActive()); String redisHost = RedisConfig.getHost(); int redisPort = Integer.valueOf(RedisConfig.getPort()); JedisPoolConfig config = new JedisPoolConfig(); config.setMaxIdle(maxIdle); config.setMaxWait(maxWait); config.setMaxActive(maxActive); config.setTestOnBorrow(false); pool = new JedisPool(config, redisHost, redisPort); &#125; catch (Exception e) &#123; LOG.error(e); throw new RuntimeException("初始化连接池错误"); &#125; &#125; public Jedis getJedis() &#123; Jedis jedis = null; boolean borrowOrOprSuccess = true; try &#123; jedis = pool.getResource(); &#125; catch (JedisConnectionException e) &#123; LOG.error(e); borrowOrOprSuccess = false; if (jedis != null) &#123; pool.returnBrokenResource(jedis); &#125; &#125; finally &#123; if (borrowOrOprSuccess) &#123; pool.returnResource(jedis); &#125; &#125; jedis = pool.getResource(); return jedis; &#125; public JedisPool getJedisPool() &#123; return this.pool; &#125; &#125; private static class SerializeUtil &#123; public static byte[] serialize(Object object) &#123; ObjectOutputStream oos = null; ByteArrayOutputStream baos = null; byte[] bytes = null; try &#123; // 序列化 baos = new ByteArrayOutputStream(); oos = new ObjectOutputStream(baos); oos.writeObject(object); bytes = baos.toByteArray(); return bytes; &#125; catch (Exception e) &#123; LOG.error(e); &#125; return bytes; &#125; public static Object unserialize(byte[] bytes) &#123; if (bytes == null) &#123; return null; &#125; ByteArrayInputStream bais = null; try &#123; // 反序列化 bais = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bais); return ois.readObject(); &#125; catch (Exception e) &#123; LOG.error(e); &#125; return null; &#125; &#125;&#125; 新建LoggingRedisCache.java类该类继承了org.apache.ibatis.cache.decorators.LoggingCache，是缓存的入口类12345public class LoggingRedisCache extends LoggingCache &#123; public LoggingRedisCache(String id) &#123; super(new RedisCache(id)); &#125;&#125; 使用缓存在需要使用缓存的mapper文件中加入（要在&lt;mapper&gt;标签范围内）：1&lt;cache type="cn.essa.component.privilege.cache.LoggingRedisCache" /&gt; 注意：测试时请记得开启redis]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[spring-boot 集成Mysql和Druid连接池]]></title>
      <url>%2F2017%2F04%2F10%2Fspring-boot%20%E9%9B%86%E6%88%90Mysql%E5%92%8CDruid%E8%BF%9E%E6%8E%A5%E6%B1%A0%2F</url>
      <content type="text"><![CDATA[概述spring-boot默认提供了数据库和数据库连接池，按照官方文档简单配置即可。若要自定义，需要修改一些配置，本文着重描述一下spring-boot如何集成mysql和阿里的druid数据库连接池。 开始本文环境 jdk：1.7 tomcat：7.0.55 spring-boot：1.2.3.RELEASE 修改application.properties文件修改spring-boot默认配置文件application.properties，加入一下内容(根据实际情况修改)：12345678910111213141516171819202122# 数据库配置spring.mysql.datasource.driverClassName=com.mysql.jdbc.Driverspring.mysql.datasource.url=jdbc:mysql://127.0.0.1:3306/message?useUnicode=true&amp;characterEncoding=utf8spring.mysql.datasource.username=rootspring.mysql.datasource.password=# 连接池配置spring.mysql.datasource.filters=statspring.mysql.datasource.maxActive=5spring.mysql.datasource.initialSize=1spring.mysql.datasource.maxWait=60000spring.mysql.datasource.minIdle=1spring.mysql.datasource.maxIdle=3spring.mysql.datasource.timeBetweenEvictionRunsMillis=60000spring.mysql.datasource.minEvictableIdleTimeMillis=300000spring.mysql.datasource.validationQuery=SELECT 'x'spring.mysql.datasource.testWhileIdle=truespring.mysql.datasource.testOnBorrow=falsespring.mysql.datasource.testOnReturn=falsespring.mysql.datasource.maxOpenPreparedStatements=10spring.mysql.datasource.removeAbandoned=truespring.mysql.datasource.removeAbandonedTimeout=1800spring.mysql.datasource.logAbandoned=true druid数据库连接池的具体配置请参考官方文档并根据项目的实际情况修改。 新建DataSourceConfig.java配置类为数据库配置单独新建一个类，内容如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112@Configurationpublic class DataSourceConfig &#123; @Value("$&#123;spring.mysql.datasource.driverClassName&#125;") private String driverClassName; @Value("$&#123;spring.mysql.datasource.url&#125;") private String url; @Value("$&#123;spring.mysql.datasource.username&#125;") private String username; @Value("$&#123;spring.mysql.datasource.password&#125;") private String password; @Value("$&#123;spring.mysql.datasource.filters&#125;") private String filters; @Value("$&#123;spring.mysql.datasource.maxActive&#125;") private int maxActive; @Value("$&#123;spring.mysql.datasource.initialSize&#125;") private int initialSize; @Value("$&#123;spring.mysql.datasource.maxWait&#125;") private long maxWait; @Value("$&#123;spring.mysql.datasource.minIdle&#125;") private int minIdle; @Value("$&#123;spring.mysql.datasource.timeBetweenEvictionRunsMillis&#125;") private long timeBetweenEvictionRunsMillis; @Value("$&#123;spring.mysql.datasource.minEvictableIdleTimeMillis&#125;") private long minEvictableIdleTimeMillis; @Value("$&#123;spring.mysql.datasource.validationQuery&#125;") private String validationQuery; @Value("$&#123;spring.mysql.datasource.testWhileIdle&#125;") private boolean testWhileIdle; @Value("$&#123;spring.mysql.datasource.testOnBorrow&#125;") private boolean testOnBorrow; @Value("$&#123;spring.mysql.datasource.testOnReturn&#125;") private boolean testOnReturn; @Value("$&#123;spring.mysql.datasource.removeAbandoned&#125;") private boolean removeAbandoned; @Value("$&#123;spring.mysql.datasource.logAbandoned&#125;") private boolean logAbandoned; @Value("$&#123;spring.mysql.datasource.maxOpenPreparedStatements&#125;") private int maxOpenPreparedStatements; @Value("$&#123;spring.mysql.datasource.removeAbandonedTimeout&#125;") private int removeAbandonedTimeout; /** * druid 数据库连接池 * @return */ @Bean(name = "mysqlDS") @Qualifier("mysqlDS") @Primary public DataSource dataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); dataSource.setDriverClassName(driverClassName); dataSource.setMaxActive(maxActive); dataSource.setInitialSize(initialSize); dataSource.setMaxWait(maxWait); dataSource.setMinIdle(minIdle); dataSource.setTimeBetweenEvictionRunsMillis(timeBetweenEvictionRunsMillis); dataSource.setMinEvictableIdleTimeMillis(minEvictableIdleTimeMillis); dataSource.setValidationQuery(validationQuery); dataSource.setTestWhileIdle(testWhileIdle); dataSource.setTestOnBorrow(testOnBorrow); dataSource.setTestOnReturn(testOnReturn); dataSource.setMaxOpenPreparedStatements(maxOpenPreparedStatements); dataSource.setRemoveAbandoned(removeAbandoned); dataSource.setRemoveAbandonedTimeout(removeAbandonedTimeout); dataSource.setLogAbandoned(logAbandoned); try &#123; dataSource.setFilters(filters); &#125; catch (SQLException e) &#123; return dataSource; &#125; return dataSource; &#125; /** * druid 监控页面 * @return */ @Bean public ServletRegistrationBean druidServletBean() &#123; ServletRegistrationBean registrationBean = new ServletRegistrationBean(); StatViewServlet statViewServlet = new StatViewServlet(); registrationBean.addInitParameter("loginUsername", "admin"); registrationBean.addInitParameter("loginPassword", "admin"); registrationBean.addInitParameter("resetEnable", "true"); registrationBean.addUrlMappings("/druid/*"); registrationBean.setServlet(statViewServlet); return registrationBean; &#125; /** * druid 资源监控过滤 * @return */ @Bean public FilterRegistrationBean druidWebStatFilter() &#123; FilterRegistrationBean registrationBean = new FilterRegistrationBean(); WebStatFilter webStatFilter = new WebStatFilter(); registrationBean.addInitParameter("sessionStatMaxCount", "2000"); registrationBean.addInitParameter("sessionStatEnable", "true"); registrationBean.addInitParameter("principalSessionName", "session_user_key"); registrationBean.addInitParameter("profileEnable", "true"); registrationBean.addInitParameter("exclusions", "*.js,*.gif,*.jpg,*.png,*.css,*.ico,*.jsp,/druid/*"); registrationBean.setFilter(webStatFilter); registrationBean.addUrlPatterns("/*"); return registrationBean; &#125;&#125; 配置了druid监控页面的登录页，用户名密码为admin。 访问druid监控页面启动应用，我tomcat的端口是8089，没有设置项目名称，因此我访问的是http://localhost:8089/druid/login.html。一般而言，druid监控登录页面的入口为：http://{IP地址}:{端口}/{项目名}/druid/login.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Logstash + Elasticsearch + Kibana 搭建日志平台]]></title>
      <url>%2F2017%2F04%2F10%2FLogstash%20%2B%20Elasticsearch%20%2B%20Kibana%20%E6%90%AD%E5%BB%BA%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0%2F</url>
      <content type="text"><![CDATA[概述日志系统中的收集、查询、显示，分别对应于Logstash、Elasticsearch、Kibana。 Logstash：是一个应用程序日志、事件的传输、处理、管理和搜索的平台 Elasticsearch：是基于lucene的开源搜索引擎 Kibana：是一个功能强大的elasticsearch数据显示客户端 日志收集采用分布式方式，使用redis作为中间缓冲队列。LEK平台结构如下： Shipper：Logstash分发端 Broker：redis缓存数据库 Indexer：Logstash收集端 Storage&amp;Search：Elasticsearch Web Interface：Kibana 安装搭建环境和所需组件： Windows7 redis64-2.8.12 logstash-1.4.2 elasticsearch-1.2.1 kibana3 安装redis启动redis服务cmd到redis64-2.8.12根目录下，输入：1redis-server 看到类似信息即可：1[5424] 28 Nov 10:06:03.898 * The server is now ready to accept connections on port 6379 安装Elasticsearch启动Elasticsearch服务cmd到elasticsearch-1.2.1\bin根目录下，输入：1elasticsearch 看到类似信息即可：1[2014-11-28 10:06:32,688][INFO ][node] [Batroc the Leaper] started 安装Logstash配置shipper.conf（日志分发）在logstash-1.4.2\bin目录下新建一个shipper.conf文件，内容如下：123456789101112131415161718input &#123; file &#123; path =&gt; "D:\error.log" type =&gt; "App-log" codec =&gt; "json" &#125;&#125;output &#123; redis &#123; host =&gt; "127.0.0.1" port =&gt; "6379" key =&gt; "testlog" data_type =&gt; "list" codec =&gt; "json" &#125;&#125; input中配置从哪里收集日志，这里表示从file（文件）中收集，地址是D:\error.log output中配置将日志信息分发到哪里，这里表示分发到redis中，配置好地址和端口等信息logstash-1.4.2\bin目录下，启动shipper的命令：1logstash agent -f shipper.conf 配置collector.conf（日志收集）在logstash-1.4.2\bin目录下新建一个collector.conf文件，内容如下：123456789101112131415161718input &#123; redis &#123; host =&gt; "127.0.0.1" port =&gt; "6379" key =&gt; "testlog" data_type =&gt; "list" type =&gt; "redis-input" codec =&gt; "json" &#125;&#125;output &#123; elasticsearch &#123; host =&gt; "127.0.0.1" &#125;&#125; 表示从reids中得到日志信息，并发送给Elasticsearch。logstash-1.4.2\bin目录下，启动collector的命令：1logstash agent -f collector.conf 安装KibanaKibana是一个webapp，把他放在web容器（如tomcat）中即可。 运行请先确保监控的日志文件存在，此处为D:\error.log。 运行redis 运行Elasticsea 运行shipper 运行collector 启动tomcat容器 打开Kibanna页面：http://localhost:8080/kibana]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaSimon]]></title>
      <url>%2F2017%2F04%2F10%2FJavaSimon%2F</url>
      <content type="text"><![CDATA[JavaSimon，是Java Simple Monitoring的意思，是Java性能监控的一个开源方案（官方说明）。本文介绍它在项目中的用法： pom.xml，加入core与dashboard的依赖12345678910&lt;dependency&gt; &lt;groupId&gt;org.javasimon&lt;/groupId&gt; &lt;artifactId&gt;javasimon-spring&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.javasimon&lt;/groupId&gt; &lt;artifactId&gt;javasimon-console-embed&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt;&lt;/dependency&gt; web.xml，加入dashboard：123456789101112&lt;servlet&gt; &lt;servlet-name&gt;SimonConsoleServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.javasimon.console.SimonConsoleServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;url-prefix&lt;/param-name&gt; &lt;param-value&gt;/javasimon&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;SimonConsoleServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/javasimon/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; applicationContext.xml 加入AOP设置12345678910&lt;!-- 调用StopWatch计时的Interceptor --&gt;&lt;bean id="monitoringInterceptor" class="org.javasimon.spring.MonitoringInterceptor" /&gt;&lt;!-- 监控定义了@Monitored的方法 --&gt;&lt;bean id="monitoringAdvisor" class="org.springframework.aop.support.DefaultPointcutAdvisor"&gt; &lt;property name="advice" ref="monitoringInterceptor" /&gt; &lt;property name="pointcut"&gt; &lt;bean class="org.javasimon.spring.MonitoredMeasuringPointcut" /&gt; &lt;/property&gt;&lt;/bean&gt; 在已知一定要监控的类或方法上加@Monitored不修改代码监控新的方法如下AOP定义片段监控了cn包或子包下的所有方法1234&lt;!-- 性能监控拦截 --&gt;&lt;aop:config&gt; &lt;aop:advisor advice-ref="monitoringInterceptor" pointcut="execution(* cn..*.*(..))" /&gt;&lt;/aop:config&gt; (可选)监控jdbc访问速度 换用新的jdbc driver，在旧的jdbc url里插入simon OracleDriver class name: org.javasimon.jdbc4.Driver instead of oracle.jdbc.OracleDriverURL: jdbc:simon:oracle:thin:@host:1521/database instead of jdbc:oracle:thin:@host:1521/database MySQLDriver class name: org.javasimon.jdbc4.Driver instead of com.mysql.jdbc.DriverURL: jdbc:simon:mysql://host:3306/database instead of jdbc:mysql://host:3306/database 使用 访问”{your webapp address}/javasimon“，如:http://localhost:8080/essa-logger/javasimon即可。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[spring-mvc 解决跨域问题]]></title>
      <url>%2F2017%2F04%2F10%2Fspring-mvc%20%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[解决跨域访问问题，只需在被访问的应用中加入一个请求过滤器： 12345678910111213141516171819202122232425262728public class CorsFilter implements Filter &#123; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; HttpServletRequest req = (HttpServletRequest) request; HttpServletResponse res = (HttpServletResponse) response; if (req.getHeader("Origin") != null) &#123; res.addHeader("Access-Control-Allow-Origin", "*"); &#125; if ("OPTIONS".equals(req.getMethod())) &#123; res.addHeader("Access-Control-Allow-Methods", "OPTIONS, GET, POST"); res.addHeader("Access-Control-Allow-Headers","Origin, Content-Type"); res.addHeader("Access-Control-Max-Age", "-1"); &#125; chain.doFilter(req, res); &#125; @Override public void destroy() &#123; &#125; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[spring-boot 中文乱码解决拾遗]]></title>
      <url>%2F2017%2F04%2F10%2Fspring-boot%20%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E8%A7%A3%E5%86%B3%E6%8B%BE%E9%81%97%2F</url>
      <content type="text"><![CDATA[在spring-boot项目中返回json格式数据时出现中文乱码问题，有以下两种解决方式： 注解形式在@RequestMapping注解中指定返回格式，编码：12345 @RequestMapping(value = &#123;"/info"&#125;, produces="application/json;charset=utf-8") @ResponseBodypublic String index() &#123; return "世界";&#125; 检查版本在spring-boot1.2.3.RELEASE版本中会出现中文乱码问题，使用上述解决方式可以解决。后来无意中把版本改为1.2.3.RELEASE，即使不在注解中指定返回格式编码，也不会出现中文乱码。初步认为高版本spring-boot中自动注册了MappingJackson2HttpMessageConverter这个bean，因此不用显示的指定，还有待考证。 -END-]]></content>
    </entry>

    
  
  
</search>
