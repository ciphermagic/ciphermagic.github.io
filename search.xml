<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Mybatis分页方案]]></title>
      <url>%2F2017%2F04%2F11%2FMybatis%E5%88%86%E9%A1%B5%E6%96%B9%E6%A1%88%2F</url>
      <content type="text"><![CDATA[概述项目开发中经常需要分页，但为了提高开发效率，开发过程中往往不考虑分页。那么如何在功能开发完后使用一种对代码侵略度最低的方式实现分页，本文将提供一种方案。 参考： Mybatis极其(最)简(好)单(用)的一个分页插件 Mybatis分页插件 - PageHelper 1. 简单使用1.1 引入分页插件添加如下maven依赖： 12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;3.6.3&lt;/version&gt;&lt;/dependency&gt; 1.2 配置Mybatis拦截器插件（以下两种方式选一种即可）1.2.1 在Mybatis配置文件中配置1234567891011121314151617181920212223242526272829303132&lt;!-- plugins在配置文件中的位置必须符合要求，否则会报错，顺序如下: properties?, settings?, typeAliases?, typeHandlers?, objectFactory?,objectWrapperFactory?, plugins?, environments?, databaseIdProvider?, mappers?--&gt;&lt;plugins&gt; &lt;!-- com.github.pagehelper为PageHelper类所在包名 --&gt; &lt;plugin interceptor="com.github.pagehelper.PageHelper"&gt; &lt;property name="dialect" value="mysql"/&gt; &lt;!-- 该参数默认为false --&gt; &lt;!-- 设置为true时，会将RowBounds第一个参数offset当成pageNum页码使用 --&gt; &lt;!-- 和startPage中的pageNum效果一样--&gt; &lt;property name="offsetAsPageNum" value="true"/&gt; &lt;!-- 该参数默认为false --&gt; &lt;!-- 设置为true时，使用RowBounds分页会进行count查询 --&gt; &lt;property name="rowBoundsWithCount" value="true"/&gt; &lt;!-- 设置为true时，如果pageSize=0或者RowBounds.limit = 0就会查询出全部的结果 --&gt; &lt;!-- （相当于没有执行分页查询，但是返回结果仍然是Page类型）--&gt; &lt;property name="pageSizeZero" value="true"/&gt; &lt;!-- 3.3.0版本可用 - 分页参数合理化，默认false禁用 --&gt; &lt;!-- 启用合理化时，如果pageNum&lt;1会查询第一页，如果pageNum&gt;pages会查询最后一页 --&gt; &lt;!-- 禁用合理化时，如果pageNum&lt;1或pageNum&gt;pages会返回空数据 --&gt; &lt;property name="reasonable" value="true"/&gt; &lt;!-- 3.5.0版本可用 - 为了支持startPage(Object params)方法 --&gt; &lt;!-- 增加了一个`params`参数来配置参数映射，用于从Map或ServletRequest中取值 --&gt; &lt;!-- 可以配置pageNum,pageSize,count,pageSizeZero,reasonable,不配置映射的用默认值 --&gt; &lt;property name="params" value="pageNum=start;pageSize=limit;pageSizeZero=zero;reasonable=heli;count=contsql"/&gt; &lt;/plugin&gt;&lt;/plugins&gt; 1.2.2 在spring配置文件中配置1234567891011121314151617181920&lt;!-- 定义SqlSessionFactoryBean --&gt;&lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 指定连接资源 --&gt; &lt;property name="dataSource" ref="druidDataSource" /&gt; &lt;!-- 指定映射文件 --&gt; &lt;property name="mapperLocations" value="classpath*:mapper/*.xml" /&gt; &lt;!-- 配置分页插件 --&gt; &lt;property name="plugins"&gt; &lt;array&gt; &lt;bean class="com.github.pagehelper.PageHelper"&gt; &lt;property name="properties"&gt; &lt;value&gt; dialect=mysql reasonable=true &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/array&gt; &lt;/property&gt;&lt;/bean&gt; 1.2 在代码中使用在你需要进行分页的Mybatis方法前调用PageHelper.startPage静态方法即可，紧跟在这个方法后的第一个Mybatis查询方法会被进行分页。 12345// startPage(第几页, 多少条数据)PageHelper.startPage(currentPage, Constant.PERPAGE_SIZE);List&lt;OperationVO&gt; resultList = operationService.queryOperations(operationVO);//用PageInfo对结果进行包装PageInfo pageInfo = new PageInfo(resultList); 如此，就能获取指定页数和数量的数据（resultList）。 PageInfo包含了非常全面的分页属性 123456789101112131415161718192021222324252627282930313233343536373839404142public class PageInfo&lt;T&gt; implements Serializable &#123; private static final long serialVersionUID = 1L; //当前页 private int pageNum; //每页的数量 private int pageSize; //当前页的数量 private int size; //由于startRow和endRow不常用，这里说个具体的用法 //可以在页面中"显示startRow到endRow 共size条数据" //当前页面第一个元素在数据库中的行号 private int startRow; //当前页面最后一个元素在数据库中的行号 private int endRow; //总记录数 private long total; //总页数 private int pages; //结果集 private List&lt;T&gt; list; //第一页 private int firstPage; //前一页 private int prePage; //下一页 private int nextPage; //最后一页 private int lastPage; //是否为第一页 private boolean isFirstPage = false; //是否为最后一页 private boolean isLastPage = false; //是否有前一页 private boolean hasPreviousPage = false; //是否有下一页 private boolean hasNextPage = false; //导航页码数 private int navigatePages; //所有导航页号 private int[] navigatepageNums; ...&#125; 可根据这些信息发送到前端实现前端分页。 2. 结合前端jquery.DataTable插件实现前端分页DataTable插件的详细使用方法请参考各搜索引擎或dataTables-使用详细说明整理 为了结合DataTable插件，需要传递一些特定的参数，为此封装了两个类。请参考(essa内网)： DataTableVO DataTableUtil 2.1 前端代码示例12345678910111213141516171819202122232425262728293031323334353637383940414243resultDataTable = $("#" + tableId).dataTable(&#123; "aLengthMenu" : [ [ 5, 10, 20 ], [ 5, 10, 20 ] ], "iDisplayLength" : 5, "bProcessing" : true, "bServerSide" : true, // 指定后台对应的url "sAjaxSource" : rootPath + "/log/getTableData.do", // 指定列的值，mData与后台返回的属性名一致 "aoColumns" : [ &#123; "mData" : "updateUserName", "sClass" : "hidden-480 center" &#125;, &#123; "mData" : "objectName", "sClass" : "hidden-480 center" &#125;, &#123; "mData" : "objectId", "sClass" : "hidden-480 center" &#125;, &#123; "mData" : "olderValue", "sClass" : "hidden-480" &#125;, &#123; "mData" : "newValue", "sClass" : "hidden-480" &#125; ], // ajax发送请求参数到后台，aaData必须包含，也可以增加自定义参数 "fnServerData" : function(sSource, aaData, fnCallback) &#123; $.ajax(&#123; "type" : "post", "url" : sSource, "dataType" : "json", "data" : &#123; aaData : JSON.stringify(aaData)， // 自定义参数，如搜索条件 custom : custom &#125;, "success" : function(resp) &#123; fnCallback(resp); &#125; &#125;); &#125;, "sPaginationType" : "bootstrap" &#125;); 2.2 后端代码示例12345678910111213141516 @RequestMapping("/getTableData.do")@ResponseBodypublic Map&lt;String, Object&gt; getTableData(String aaData, HistoryVO historyVO) &#123; // 接收DataTable插件传递的aaData，封装成DataTableVO DataTableVO&lt;HistoryVO&gt; table = DataTableUtil.getDataTableVO(aaData); // 开始分页 PageHelper.startPage(table.getPageIndex(), table.getiDisplayLength()); List&lt;HistoryVO&gt; resultList = historyService.queryHistory(historyVO); PageInfo pageInfo = new PageInfo(resultList); // 根据分页结果设置table参数 table.setiTotalRecords(pageInfo.getTotal()); table.setAaData(resultList); // 返回DataTable相应的json数据 Map&lt;String, Object&gt; dataMap = DataTableUtil.getReturnMap(table); return dataMap;&#125; 通过上述示例方法返回json数据到前台，DataTable接收显示分页数据。 3. 使用EL表达式实现前端分页的一个示例 后台发送pageInfo到前台 1model.addAttribute("page", pageInfo); 前台使用EL表达式实现分页，pageInfo中的各项参数请参考1.2节 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;div class="row-fluid"&gt; &lt;div class="span6"&gt; &lt;div id="user_group_table_info" class="dataTables_info" role="status" aria-live="polite"&gt;显示第 $&#123;page.startRow&#125; - $&#123;page.endRow&#125; 条数据; 共有$&#123;page.total&#125; 条记录&lt;/div&gt; &lt;/div&gt; &lt;div class="span6"&gt; &lt;div id="role_group_table_paginate" class="dataTables_paginate paging_bootstrap pagination"&gt; &lt;ul&gt; &lt;c:choose&gt; &lt;c:when test="$&#123;page.isFirstPage&#125;"&gt; &lt;li class="prev disabled"&gt;&lt;a href="#"&gt; ← &lt;span class="hidden-480"&gt;上一页&lt;/span&gt; &lt;/a&gt;&lt;/li&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; &lt;li class="prev"&gt;&lt;a href="$&#123;currentPath&#125;?pageNum=$&#123;page.prePage&#125;"&gt; ← &lt;span class="hidden-480"&gt;上一页&lt;/span&gt; &lt;/a&gt;&lt;/li&gt; &lt;/c:otherwise&gt; &lt;/c:choose&gt; &lt;c:forEach begin="1" end="$&#123;page.pages&#125;" var="p"&gt; &lt;c:choose&gt; &lt;c:when test="$&#123;p == page.pageNum&#125;"&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;$&#123;p&#125;&lt;/a&gt;&lt;/li&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; &lt;li class=""&gt;&lt;a href="$&#123;currentPath&#125;?pageNum=$&#123;p&#125;"&gt;$&#123;p&#125;&lt;/a&gt;&lt;/li&gt; &lt;/c:otherwise&gt; &lt;/c:choose&gt; &lt;/c:forEach&gt; &lt;c:choose&gt; &lt;c:when test="$&#123;page.isLastPage&#125;"&gt; &lt;li class="next disabled"&gt;&lt;a href="#"&gt;&lt;span class="hidden-480"&gt;下一页&lt;/span&gt; → &lt;/a&gt;&lt;/li&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; &lt;li class="next"&gt;&lt;a href="$&#123;currentPath&#125;?pageNum=$&#123;page.nextPage&#125;"&gt; &lt;span class="hidden-480"&gt;下一页&lt;/span&gt; → &lt;/a&gt;&lt;/li&gt; &lt;/c:otherwise&gt; &lt;/c:choose&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 总结在使用此Mybatis分页插件时，不需要在分页的地方手写分页sql和count的sql，不需要更改已有的业务代码，只需要在执行sql前调用一句代码，即可实现分页，并得到丰富的分页信息。有了这些分页信息，前端可以选用多种分页方法，非常方便。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Logstash + Elasticsearch + Kibana 搭建日志平台]]></title>
      <url>%2F2017%2F04%2F11%2FLogstash%20%2B%20Elasticsearch%20%2B%20Kibana%20%E6%90%AD%E5%BB%BA%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0%2F</url>
      <content type="text"><![CDATA[概述日志系统中的收集、查询、显示，分别对应于Logstash、Elasticsearch、Kibana。 Logstash：是一个应用程序日志、事件的传输、处理、管理和搜索的平台 Elasticsearch：是基于lucene的开源搜索引擎 Kibana：是一个功能强大的elasticsearch数据显示客户端 日志收集采用分布式方式，使用redis作为中间缓冲队列。LEK平台结构如下： Shipper：Logstash分发端 Broker：redis缓存数据库 Indexer：Logstash收集端 Storage&amp;Search：Elasticsearch Web Interface：Kibana 安装搭建环境和所需组件： Windows7 redis64-2.8.12 logstash-1.4.2 elasticsearch-1.2.1 kibana3 安装redis启动redis服务cmd到redis64-2.8.12根目录下，输入：1redis-server 看到类似信息即可：1[5424] 28 Nov 10:06:03.898 * The server is now ready to accept connections on port 6379 安装Elasticsearch启动Elasticsearch服务cmd到elasticsearch-1.2.1\bin根目录下，输入：1elasticsearch 看到类似信息即可：1[2014-11-28 10:06:32,688][INFO ][node] [Batroc the Leaper] started 安装Logstash配置shipper.conf（日志分发）在logstash-1.4.2\bin目录下新建一个shipper.conf文件，内容如下：123456789101112131415161718input &#123; file &#123; path =&gt; "D:\error.log" type =&gt; "App-log" codec =&gt; "json" &#125;&#125;output &#123; redis &#123; host =&gt; "127.0.0.1" port =&gt; "6379" key =&gt; "testlog" data_type =&gt; "list" codec =&gt; "json" &#125;&#125; input中配置从哪里收集日志，这里表示从file（文件）中收集，地址是D:\error.log output中配置将日志信息分发到哪里，这里表示分发到redis中，配置好地址和端口等信息logstash-1.4.2\bin目录下，启动shipper的命令：1logstash agent -f shipper.conf 配置collector.conf（日志收集）在logstash-1.4.2\bin目录下新建一个collector.conf文件，内容如下：123456789101112131415161718input &#123; redis &#123; host =&gt; "127.0.0.1" port =&gt; "6379" key =&gt; "testlog" data_type =&gt; "list" type =&gt; "redis-input" codec =&gt; "json" &#125;&#125;output &#123; elasticsearch &#123; host =&gt; "127.0.0.1" &#125;&#125; 表示从reids中得到日志信息，并发送给Elasticsearch。logstash-1.4.2\bin目录下，启动collector的命令：1logstash agent -f collector.conf 安装KibanaKibana是一个webapp，把他放在web容器（如tomcat）中即可。 运行请先确保监控的日志文件存在，此处为D:\error.log。 运行redis 运行Elasticsea 运行shipper 运行collector 启动tomcat容器 打开Kibanna页面：http://localhost:8080/kibana]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaSimon]]></title>
      <url>%2F2017%2F04%2F11%2FJavaSimon%2F</url>
      <content type="text"><![CDATA[JavaSimon，是Java Simple Monitoring的意思，是Java性能监控的一个开源方案（官方说明）。本文介绍它在项目中的用法： pom.xml，加入core与dashboard的依赖 12345678910&lt;dependency&gt; &lt;groupId&gt;org.javasimon&lt;/groupId&gt; &lt;artifactId&gt;javasimon-spring&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.javasimon&lt;/groupId&gt; &lt;artifactId&gt;javasimon-console-embed&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt;&lt;/dependency&gt; web.xml，加入dashboard： 123456789101112&lt;servlet&gt; &lt;servlet-name&gt;SimonConsoleServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.javasimon.console.SimonConsoleServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;url-prefix&lt;/param-name&gt; &lt;param-value&gt;/javasimon&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;SimonConsoleServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/javasimon/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; applicationContext.xml 加入AOP设置 12345678910&lt;!-- 调用StopWatch计时的Interceptor --&gt;&lt;bean id="monitoringInterceptor" class="org.javasimon.spring.MonitoringInterceptor" /&gt;&lt;!-- 监控定义了@Monitored的方法 --&gt;&lt;bean id="monitoringAdvisor" class="org.springframework.aop.support.DefaultPointcutAdvisor"&gt; &lt;property name="advice" ref="monitoringInterceptor" /&gt; &lt;property name="pointcut"&gt; &lt;bean class="org.javasimon.spring.MonitoredMeasuringPointcut" /&gt; &lt;/property&gt;&lt;/bean&gt; 在已知一定要监控的类或方法上加@Monitored 不修改代码监控新的方法如下AOP定义片段监控了cn包或子包下的所有方法 1234&lt;!-- 性能监控拦截 --&gt;&lt;aop:config&gt; &lt;aop:advisor advice-ref="monitoringInterceptor" pointcut="execution(* cn..*.*(..))" /&gt;&lt;/aop:config&gt; (可选)监控jdbc访问速度 换用新的jdbc driver，在旧的jdbc url里插入simon OracleDriver class name: org.javasimon.jdbc4.Driver instead of oracle.jdbc.OracleDriverURL: jdbc:simon:oracle:thin:@host:1521/database instead of jdbc:oracle:thin:@host:1521/database MySQLDriver class name: org.javasimon.jdbc4.Driver instead of com.mysql.jdbc.DriverURL: jdbc:simon:mysql://host:3306/database instead of jdbc:mysql://host:3306/database 使用访问”{your webapp address}/javasimon“，如:http://localhost:8080/essa-logger/javasimon即可。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mybatis整合redis实现缓存]]></title>
      <url>%2F2017%2F04%2F11%2FMybatis%E6%95%B4%E5%90%88redis%E5%AE%9E%E7%8E%B0%E7%BC%93%E5%AD%98%2F</url>
      <content type="text"><![CDATA[概述Mybatis默认缓存是PerpetualCache，它实现了Cache接口。Mybatis为了方便我们扩展缓存定义了一个Cache接口，因此，我们只需要参考源码自己使用redis实现Cache接口，即可达到Mybatis整合redis管理缓存的目的。 开始本文介绍在spring-mvc的项目中，如何实现使用redis作为Mybatis的二级缓存。重点是实现Cache接口，而如何引入redis有多种方式，本文使用其中一种。 环境 jdk：1.7 redis：2.8.12 spring：4.1.1.RELEASE 新建redis.properties文件用于记录redis的基本信息1234567891011# ====================================================# redis settings# ====================================================redis.host=127.0.0.1redis.port=6379redis.pass=redis.maxIdle=300redis.maxActive=600redis.maxWait=1000redis.testOnBorrow=false 新建RedisConfig.java类用于获取redis配置信息12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class RedisConfig &#123; private static String host; private static String port; private static String pass; private static String maxIdle; private static String maxActive; private static String maxWait; private static String testOnBorrow; public RedisConfig(String host, String port, String pass, String maxIdle, String maxActive, String maxWait, String testOnBorrow) &#123; super(); RedisConfig.host = host; RedisConfig.port = port; RedisConfig.pass = pass; RedisConfig.maxIdle = maxIdle; RedisConfig.maxActive = maxActive; RedisConfig.maxWait = maxWait; RedisConfig.testOnBorrow = testOnBorrow; &#125; public static String getHost() &#123; return host; &#125; public static String getPort() &#123; return port; &#125; public static String getPass() &#123; return pass; &#125; public static String getMaxIdle() &#123; return maxIdle; &#125; public static String getMaxActive() &#123; return maxActive; &#125; public static String getMaxWait() &#123; return maxWait; &#125; public static String getTestOnBorrow() &#123; return testOnBorrow; &#125; public void setHost(String host) &#123; RedisConfig.host = host; &#125; public void setPort(String port) &#123; RedisConfig.port = port; &#125; public void setPass(String pass) &#123; RedisConfig.pass = pass; &#125; public void setMaxIdle(String maxIdle) &#123; RedisConfig.maxIdle = maxIdle; &#125; public void setMaxActive(String maxActive) &#123; RedisConfig.maxActive = maxActive; &#125; public void setMaxWait(String maxWait) &#123; RedisConfig.maxWait = maxWait; &#125; public void setTestOnBorrow(String testOnBorrow) &#123; RedisConfig.testOnBorrow = testOnBorrow; &#125;&#125; spring配置文件中构造RedisConfig123456789101112131415161718192021222324252627&lt;context:property-placeholder location="classpath:redis.properties" ignore-unresolvable="true" ignore-resource-not-found="true" /&gt;&lt;bean id="redisConfig" class="cn.essa.component.privilege.util.RedisConfig"&gt; &lt;constructor-arg index="0"&gt; &lt;value&gt;$&#123;redis.host&#125;&lt;/value&gt; &lt;/constructor-arg&gt; &lt;constructor-arg index="1"&gt; &lt;value&gt;$&#123;redis.port&#125;&lt;/value&gt; &lt;/constructor-arg&gt; &lt;constructor-arg index="2"&gt; &lt;value&gt;$&#123;redis.pass&#125;&lt;/value&gt; &lt;/constructor-arg&gt; &lt;constructor-arg index="3"&gt; &lt;value&gt;$&#123;redis.maxIdle&#125;&lt;/value&gt; &lt;/constructor-arg&gt; &lt;constructor-arg index="4"&gt; &lt;value&gt;$&#123;redis.maxActive&#125;&lt;/value&gt; &lt;/constructor-arg&gt; &lt;constructor-arg index="5"&gt; &lt;value&gt;$&#123;redis.maxWait&#125;&lt;/value&gt; &lt;/constructor-arg&gt; &lt;constructor-arg index="6"&gt; &lt;value&gt;$&#123;redis.testOnBorrow&#125;&lt;/value&gt; &lt;/constructor-arg&gt;&lt;/bean&gt; 如此即可在普通类中使用RedisConfig，得到redis配置信息 新建RedisCache.java类该类实现了org.apache.ibatis.cache.Cache接口123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263/** * @ClassName: RedisCache * @Description: 使用第三方缓存服务器redis，处理二级缓存 * @author cipher * */public class RedisCache implements Cache &#123; private static final Log LOG = LogFactory.getLog(RedisCache.class); /** The ReadWriteLock. */ private final ReadWriteLock readWriteLock = new ReentrantReadWriteLock(); private String id; public RedisCache(final String id) &#123; if (id == null) &#123; throw new IllegalArgumentException("必须传入ID"); &#125; LOG.debug("&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;MybatisRedisCache:id=" + id); this.id = id; &#125; @Override public String getId() &#123; return this.id; &#125; @Override public int getSize() &#123; Jedis jedis = null; JedisPool jedisPool = null; int result = 0; boolean borrowOrOprSuccess = true; try &#123; jedis = CachePool.getInstance().getJedis(); jedisPool = CachePool.getInstance().getJedisPool(); result = Integer.valueOf(jedis.dbSize().toString()); &#125; catch (JedisConnectionException e) &#123; LOG.error(e); borrowOrOprSuccess = false; if (jedis != null) &#123; jedisPool.returnBrokenResource(jedis); &#125; &#125; finally &#123; if (borrowOrOprSuccess) &#123; jedisPool.returnResource(jedis); &#125; &#125; return result; &#125; @Override public void putObject(Object key, Object value) &#123; if (LOG.isDebugEnabled()) &#123; LOG.debug("&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;putObject:" + key.hashCode() + "=" + value); &#125; if (LOG.isInfoEnabled()) &#123; LOG.info("&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;put to redis sql :" + key.toString()); &#125; Jedis jedis = null; JedisPool jedisPool = null; boolean borrowOrOprSuccess = true; try &#123; jedis = CachePool.getInstance().getJedis(); jedisPool = CachePool.getInstance().getJedisPool(); jedis.set(SerializeUtil.serialize(key.hashCode()), SerializeUtil.serialize(value)); &#125; catch (JedisConnectionException e) &#123; LOG.error(e); borrowOrOprSuccess = false; if (jedis != null) &#123; jedisPool.returnBrokenResource(jedis); &#125; &#125; finally &#123; if (borrowOrOprSuccess) &#123; jedisPool.returnResource(jedis); &#125; &#125; &#125; @Override public Object getObject(Object key) &#123; Jedis jedis = null; JedisPool jedisPool = null; Object value = null; boolean borrowOrOprSuccess = true; try &#123; jedis = CachePool.getInstance().getJedis(); jedisPool = CachePool.getInstance().getJedisPool(); value = SerializeUtil.unserialize(jedis.get(SerializeUtil .serialize(key.hashCode()))); &#125; catch (JedisConnectionException e) &#123; LOG.error(e); borrowOrOprSuccess = false; if (jedis != null) &#123; jedisPool.returnBrokenResource(jedis); &#125; &#125; finally &#123; if (borrowOrOprSuccess) &#123; jedisPool.returnResource(jedis); &#125; &#125; if (LOG.isDebugEnabled()) &#123; LOG.debug("&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;getObject:" + key.hashCode() + "=" + value); &#125; return value; &#125; @Override public Object removeObject(Object key) &#123; Jedis jedis = null; JedisPool jedisPool = null; Object value = null; boolean borrowOrOprSuccess = true; try &#123; jedis = CachePool.getInstance().getJedis(); jedisPool = CachePool.getInstance().getJedisPool(); value = jedis.expire(SerializeUtil.serialize(key.hashCode()), 0); &#125; catch (JedisConnectionException e) &#123; LOG.error(e); borrowOrOprSuccess = false; if (jedis != null) &#123; jedisPool.returnBrokenResource(jedis); &#125; &#125; finally &#123; if (borrowOrOprSuccess) &#123; jedisPool.returnResource(jedis); &#125; &#125; if (LOG.isDebugEnabled()) &#123; LOG.debug("&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;removeObject:" + key.hashCode() + "=" + value); &#125; return value; &#125; @Override public void clear() &#123; Jedis jedis = null; JedisPool jedisPool = null; boolean borrowOrOprSuccess = true; try &#123; jedis = CachePool.getInstance().getJedis(); jedisPool = CachePool.getInstance().getJedisPool(); jedis.flushDB(); jedis.flushAll(); &#125; catch (JedisConnectionException e) &#123; LOG.error(e); borrowOrOprSuccess = false; if (jedis != null) &#123; jedisPool.returnBrokenResource(jedis); &#125; &#125; finally &#123; if (borrowOrOprSuccess) &#123; jedisPool.returnResource(jedis); &#125; &#125; &#125; @Override public ReadWriteLock getReadWriteLock() &#123; return readWriteLock; &#125; /** * * @ClassName: CachePool * @Description: 单例Cache池 * */ public static class CachePool &#123; JedisPool pool; private static final CachePool CACHEPOOL = new CachePool(); public static CachePool getInstance() &#123; return CACHEPOOL; &#125; private CachePool() &#123; try &#123; int maxIdle = Integer .valueOf(RedisConfig.getMaxIdle()); long maxWait = Long.valueOf(RedisConfig.getMaxWait()); int maxActive = Integer.valueOf(RedisConfig.getMaxActive()); String redisHost = RedisConfig.getHost(); int redisPort = Integer.valueOf(RedisConfig.getPort()); JedisPoolConfig config = new JedisPoolConfig(); config.setMaxIdle(maxIdle); config.setMaxWait(maxWait); config.setMaxActive(maxActive); config.setTestOnBorrow(false); pool = new JedisPool(config, redisHost, redisPort); &#125; catch (Exception e) &#123; LOG.error(e); throw new RuntimeException("初始化连接池错误"); &#125; &#125; public Jedis getJedis() &#123; Jedis jedis = null; boolean borrowOrOprSuccess = true; try &#123; jedis = pool.getResource(); &#125; catch (JedisConnectionException e) &#123; LOG.error(e); borrowOrOprSuccess = false; if (jedis != null) &#123; pool.returnBrokenResource(jedis); &#125; &#125; finally &#123; if (borrowOrOprSuccess) &#123; pool.returnResource(jedis); &#125; &#125; jedis = pool.getResource(); return jedis; &#125; public JedisPool getJedisPool() &#123; return this.pool; &#125; &#125; private static class SerializeUtil &#123; public static byte[] serialize(Object object) &#123; ObjectOutputStream oos = null; ByteArrayOutputStream baos = null; byte[] bytes = null; try &#123; // 序列化 baos = new ByteArrayOutputStream(); oos = new ObjectOutputStream(baos); oos.writeObject(object); bytes = baos.toByteArray(); return bytes; &#125; catch (Exception e) &#123; LOG.error(e); &#125; return bytes; &#125; public static Object unserialize(byte[] bytes) &#123; if (bytes == null) &#123; return null; &#125; ByteArrayInputStream bais = null; try &#123; // 反序列化 bais = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bais); return ois.readObject(); &#125; catch (Exception e) &#123; LOG.error(e); &#125; return null; &#125; &#125;&#125; 新建LoggingRedisCache.java类该类继承了org.apache.ibatis.cache.decorators.LoggingCache，是缓存的入口类12345public class LoggingRedisCache extends LoggingCache &#123; public LoggingRedisCache(String id) &#123; super(new RedisCache(id)); &#125;&#125; 使用缓存在需要使用缓存的mapper文件中加入（要在&lt;mapper&gt;标签范围内）：1&lt;cache type="cn.essa.component.privilege.cache.LoggingRedisCache" /&gt; 注意：测试时请记得开启redis]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Maven初探]]></title>
      <url>%2F2017%2F04%2F11%2FMaven%E5%88%9D%E6%8E%A2%2F</url>
      <content type="text"><![CDATA[最近刚接触了Maven，就根据自己的理解介绍一下Maven在开发中怎么用，顺便巩固一下知识。 Maven是什么我目前使用Maven主要是管理项目中jar包，其它高级的用法暂时还没涉及到。我们为什么要用Maven帮我们管理jar包呢，一个是我们不需要自己再到各个第三方框架或技术的网站上下载jar包了，另外一个是很好的统一了项目中各jar包的版本，因为多人开发中使用不同版本的jar包可能会有版本的冲突问题。Maven提供一个中央仓库，里面有几乎所有主流技术的jar包，我们只需要在配置文件中指定好要使用的jar，Maven就会帮我们自动下载。Maven会在本地建一个仓库，第一次下载的jar包放在本地仓库里，Maven根据配置注入jar的时候先从本地仓库里查找，如果没有再从远程中央仓库里下载，提高了效率。 如何安装和配置Maven安装Maven跟安装Jdk差不多，我们只需要把Maven下载下来，在环境变量中新建一个变量%MAVEN_HOME%，再在path中加上%MAVEN_HOME%/bin，如此，我们就能在控制台中使用Maven的命令了，我们可以在控制台输入mvn -v，如果成功输入Maven的版本信息，就说明Maven已经能正常工作了。但是，在使用之前我们做一些简单的修改来更好的使用Maven。 一些必要的修改首先，在Maven根目录下进入conf文件夹找到settings.xml配置文件，它可以配置Maven各种信息。在文件里面找到&lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;，这一行是配置Maven本地仓库的路径，把标签中的路径换成自己指定的路径例如E:\apache-maven-3.2.3-bin\Repository，要在对应的地方把这个文件夹新建好，这样Maven下载下来的jar包就会存到这个文件夹中。注意这一行在文件中是注释掉的，要把注释打开。接着，在配置文件中找到&lt;proxies&gt;标签，这里是设置Maven的镜像，如果我们有自己局域网内的中央仓库，可以在这里设置，这样Maven就会从我们局域网中的仓库下载，速度就会快很多。在日常开发中主要是设置这两个地方。 在Eclipse中集成Maven安装Maven插件我使用的是Eclipse版本是kepler，首先要安装Maven插件，在菜单栏中选择Help——Install New Software…接着你会看到一个Install对话框，点击Work with:字段边上的Add按钮，你会得到一个新的Add Repository对话框，在Name字段中输入m2e，Location字段中输入在线安装地址，这里提供一个地址，如果失效了可以在网上再找。然后点击OK。Eclipse会下载m2eclipse安装站点上的资源信息。 加入本地Maven依次选择菜单Windows——Preferences——Maven——Installations，然后在界面中点击Add，选择本地Maven的根目录，这样我们就设置好Maven插件了。 Eclipse创建Maven项目新建项目选择Maven Project，勾选Use default Workspace location使用默认的Workspace路径，点Next，一般的Web项目我们选择webapp点Next，输入工程信息， Group Id类似一个包名，Artifact Id类似类名。其它默认即可。点Finish就完成创建了。完成后我们能在项目中找到一个pom.xml文件，里面就可以配置我们项目中所需的依赖jar包了。 最后以上就是我最近初学Maven的一点认识，Maven确实是一个很好的构建工具，而也不仅仅是一个构建工具。更深的了解还要在以后的学习当中去探索。-END-]]></content>
    </entry>

    
  
  
</search>
