<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F04%2F11%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mybatis整合redis实现缓存]]></title>
      <url>%2F2017%2F04%2F11%2FMybatis%E6%95%B4%E5%90%88redis%E5%AE%9E%E7%8E%B0%E7%BC%93%E5%AD%98%2F</url>
      <content type="text"><![CDATA[概述Mybatis默认缓存是PerpetualCache，它实现了Cache接口。Mybatis为了方便我们扩展缓存定义了一个Cache接口，因此，我们只需要参考源码自己使用redis实现Cache接口，即可达到Mybatis整合redis管理缓存的目的。 开始本文介绍在spring-mvc的项目中，如何实现使用redis作为Mybatis的二级缓存。重点是实现Cache接口，而如何引入redis有多种方式，本文使用其中一种。 环境 jdk：1.7 redis：2.8.12 spring：4.1.1.RELEASE 新建redis.properties文件用于记录redis的基本信息1234567891011# ====================================================# redis settings# ====================================================redis.host=127.0.0.1redis.port=6379redis.pass=redis.maxIdle=300redis.maxActive=600redis.maxWait=1000redis.testOnBorrow=false 新建RedisConfig.java类用于获取redis配置信息12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class RedisConfig &#123; private static String host; private static String port; private static String pass; private static String maxIdle; private static String maxActive; private static String maxWait; private static String testOnBorrow; public RedisConfig(String host, String port, String pass, String maxIdle, String maxActive, String maxWait, String testOnBorrow) &#123; super(); RedisConfig.host = host; RedisConfig.port = port; RedisConfig.pass = pass; RedisConfig.maxIdle = maxIdle; RedisConfig.maxActive = maxActive; RedisConfig.maxWait = maxWait; RedisConfig.testOnBorrow = testOnBorrow; &#125; public static String getHost() &#123; return host; &#125; public static String getPort() &#123; return port; &#125; public static String getPass() &#123; return pass; &#125; public static String getMaxIdle() &#123; return maxIdle; &#125; public static String getMaxActive() &#123; return maxActive; &#125; public static String getMaxWait() &#123; return maxWait; &#125; public static String getTestOnBorrow() &#123; return testOnBorrow; &#125; public void setHost(String host) &#123; RedisConfig.host = host; &#125; public void setPort(String port) &#123; RedisConfig.port = port; &#125; public void setPass(String pass) &#123; RedisConfig.pass = pass; &#125; public void setMaxIdle(String maxIdle) &#123; RedisConfig.maxIdle = maxIdle; &#125; public void setMaxActive(String maxActive) &#123; RedisConfig.maxActive = maxActive; &#125; public void setMaxWait(String maxWait) &#123; RedisConfig.maxWait = maxWait; &#125; public void setTestOnBorrow(String testOnBorrow) &#123; RedisConfig.testOnBorrow = testOnBorrow; &#125;&#125; spring配置文件中构造RedisConfig123456789101112131415161718192021222324252627&lt;context:property-placeholder location="classpath:redis.properties" ignore-unresolvable="true" ignore-resource-not-found="true" /&gt;&lt;bean id="redisConfig" class="cn.essa.component.privilege.util.RedisConfig"&gt; &lt;constructor-arg index="0"&gt; &lt;value&gt;$&#123;redis.host&#125;&lt;/value&gt; &lt;/constructor-arg&gt; &lt;constructor-arg index="1"&gt; &lt;value&gt;$&#123;redis.port&#125;&lt;/value&gt; &lt;/constructor-arg&gt; &lt;constructor-arg index="2"&gt; &lt;value&gt;$&#123;redis.pass&#125;&lt;/value&gt; &lt;/constructor-arg&gt; &lt;constructor-arg index="3"&gt; &lt;value&gt;$&#123;redis.maxIdle&#125;&lt;/value&gt; &lt;/constructor-arg&gt; &lt;constructor-arg index="4"&gt; &lt;value&gt;$&#123;redis.maxActive&#125;&lt;/value&gt; &lt;/constructor-arg&gt; &lt;constructor-arg index="5"&gt; &lt;value&gt;$&#123;redis.maxWait&#125;&lt;/value&gt; &lt;/constructor-arg&gt; &lt;constructor-arg index="6"&gt; &lt;value&gt;$&#123;redis.testOnBorrow&#125;&lt;/value&gt; &lt;/constructor-arg&gt;&lt;/bean&gt; 如此即可在普通类中使用RedisConfig，得到redis配置信息 新建RedisCache.java类该类实现了org.apache.ibatis.cache.Cache接口123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263/** * @ClassName: RedisCache * @Description: 使用第三方缓存服务器redis，处理二级缓存 * @author cipher * */public class RedisCache implements Cache &#123; private static final Log LOG = LogFactory.getLog(RedisCache.class); /** The ReadWriteLock. */ private final ReadWriteLock readWriteLock = new ReentrantReadWriteLock(); private String id; public RedisCache(final String id) &#123; if (id == null) &#123; throw new IllegalArgumentException("必须传入ID"); &#125; LOG.debug("&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;MybatisRedisCache:id=" + id); this.id = id; &#125; @Override public String getId() &#123; return this.id; &#125; @Override public int getSize() &#123; Jedis jedis = null; JedisPool jedisPool = null; int result = 0; boolean borrowOrOprSuccess = true; try &#123; jedis = CachePool.getInstance().getJedis(); jedisPool = CachePool.getInstance().getJedisPool(); result = Integer.valueOf(jedis.dbSize().toString()); &#125; catch (JedisConnectionException e) &#123; LOG.error(e); borrowOrOprSuccess = false; if (jedis != null) &#123; jedisPool.returnBrokenResource(jedis); &#125; &#125; finally &#123; if (borrowOrOprSuccess) &#123; jedisPool.returnResource(jedis); &#125; &#125; return result; &#125; @Override public void putObject(Object key, Object value) &#123; if (LOG.isDebugEnabled()) &#123; LOG.debug("&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;putObject:" + key.hashCode() + "=" + value); &#125; if (LOG.isInfoEnabled()) &#123; LOG.info("&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;put to redis sql :" + key.toString()); &#125; Jedis jedis = null; JedisPool jedisPool = null; boolean borrowOrOprSuccess = true; try &#123; jedis = CachePool.getInstance().getJedis(); jedisPool = CachePool.getInstance().getJedisPool(); jedis.set(SerializeUtil.serialize(key.hashCode()), SerializeUtil.serialize(value)); &#125; catch (JedisConnectionException e) &#123; LOG.error(e); borrowOrOprSuccess = false; if (jedis != null) &#123; jedisPool.returnBrokenResource(jedis); &#125; &#125; finally &#123; if (borrowOrOprSuccess) &#123; jedisPool.returnResource(jedis); &#125; &#125; &#125; @Override public Object getObject(Object key) &#123; Jedis jedis = null; JedisPool jedisPool = null; Object value = null; boolean borrowOrOprSuccess = true; try &#123; jedis = CachePool.getInstance().getJedis(); jedisPool = CachePool.getInstance().getJedisPool(); value = SerializeUtil.unserialize(jedis.get(SerializeUtil .serialize(key.hashCode()))); &#125; catch (JedisConnectionException e) &#123; LOG.error(e); borrowOrOprSuccess = false; if (jedis != null) &#123; jedisPool.returnBrokenResource(jedis); &#125; &#125; finally &#123; if (borrowOrOprSuccess) &#123; jedisPool.returnResource(jedis); &#125; &#125; if (LOG.isDebugEnabled()) &#123; LOG.debug("&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;getObject:" + key.hashCode() + "=" + value); &#125; return value; &#125; @Override public Object removeObject(Object key) &#123; Jedis jedis = null; JedisPool jedisPool = null; Object value = null; boolean borrowOrOprSuccess = true; try &#123; jedis = CachePool.getInstance().getJedis(); jedisPool = CachePool.getInstance().getJedisPool(); value = jedis.expire(SerializeUtil.serialize(key.hashCode()), 0); &#125; catch (JedisConnectionException e) &#123; LOG.error(e); borrowOrOprSuccess = false; if (jedis != null) &#123; jedisPool.returnBrokenResource(jedis); &#125; &#125; finally &#123; if (borrowOrOprSuccess) &#123; jedisPool.returnResource(jedis); &#125; &#125; if (LOG.isDebugEnabled()) &#123; LOG.debug("&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;removeObject:" + key.hashCode() + "=" + value); &#125; return value; &#125; @Override public void clear() &#123; Jedis jedis = null; JedisPool jedisPool = null; boolean borrowOrOprSuccess = true; try &#123; jedis = CachePool.getInstance().getJedis(); jedisPool = CachePool.getInstance().getJedisPool(); jedis.flushDB(); jedis.flushAll(); &#125; catch (JedisConnectionException e) &#123; LOG.error(e); borrowOrOprSuccess = false; if (jedis != null) &#123; jedisPool.returnBrokenResource(jedis); &#125; &#125; finally &#123; if (borrowOrOprSuccess) &#123; jedisPool.returnResource(jedis); &#125; &#125; &#125; @Override public ReadWriteLock getReadWriteLock() &#123; return readWriteLock; &#125; /** * * @ClassName: CachePool * @Description: 单例Cache池 * */ public static class CachePool &#123; JedisPool pool; private static final CachePool CACHEPOOL = new CachePool(); public static CachePool getInstance() &#123; return CACHEPOOL; &#125; private CachePool() &#123; try &#123; int maxIdle = Integer .valueOf(RedisConfig.getMaxIdle()); long maxWait = Long.valueOf(RedisConfig.getMaxWait()); int maxActive = Integer.valueOf(RedisConfig.getMaxActive()); String redisHost = RedisConfig.getHost(); int redisPort = Integer.valueOf(RedisConfig.getPort()); JedisPoolConfig config = new JedisPoolConfig(); config.setMaxIdle(maxIdle); config.setMaxWait(maxWait); config.setMaxActive(maxActive); config.setTestOnBorrow(false); pool = new JedisPool(config, redisHost, redisPort); &#125; catch (Exception e) &#123; LOG.error(e); throw new RuntimeException("初始化连接池错误"); &#125; &#125; public Jedis getJedis() &#123; Jedis jedis = null; boolean borrowOrOprSuccess = true; try &#123; jedis = pool.getResource(); &#125; catch (JedisConnectionException e) &#123; LOG.error(e); borrowOrOprSuccess = false; if (jedis != null) &#123; pool.returnBrokenResource(jedis); &#125; &#125; finally &#123; if (borrowOrOprSuccess) &#123; pool.returnResource(jedis); &#125; &#125; jedis = pool.getResource(); return jedis; &#125; public JedisPool getJedisPool() &#123; return this.pool; &#125; &#125; private static class SerializeUtil &#123; public static byte[] serialize(Object object) &#123; ObjectOutputStream oos = null; ByteArrayOutputStream baos = null; byte[] bytes = null; try &#123; // 序列化 baos = new ByteArrayOutputStream(); oos = new ObjectOutputStream(baos); oos.writeObject(object); bytes = baos.toByteArray(); return bytes; &#125; catch (Exception e) &#123; LOG.error(e); &#125; return bytes; &#125; public static Object unserialize(byte[] bytes) &#123; if (bytes == null) &#123; return null; &#125; ByteArrayInputStream bais = null; try &#123; // 反序列化 bais = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bais); return ois.readObject(); &#125; catch (Exception e) &#123; LOG.error(e); &#125; return null; &#125; &#125;&#125; 新建LoggingRedisCache.java类该类继承了org.apache.ibatis.cache.decorators.LoggingCache，是缓存的入口类12345public class LoggingRedisCache extends LoggingCache &#123; public LoggingRedisCache(String id) &#123; super(new RedisCache(id)); &#125;&#125; 使用缓存在需要使用缓存的mapper文件中加入（要在&lt;mapper&gt;标签范围内）：1&lt;cache type="cn.essa.component.privilege.cache.LoggingRedisCache" /&gt; 注意：测试时请记得开启redis]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Maven初探]]></title>
      <url>%2F2017%2F04%2F11%2FMaven%E5%88%9D%E6%8E%A2%2F</url>
      <content type="text"><![CDATA[最近刚接触了Maven，就根据自己的理解介绍一下Maven在开发中怎么用，顺便巩固一下知识。 Maven是什么我目前使用Maven主要是管理项目中jar包，其它高级的用法暂时还没涉及到。我们为什么要用Maven帮我们管理jar包呢，一个是我们不需要自己再到各个第三方框架或技术的网站上下载jar包了，另外一个是很好的统一了项目中各jar包的版本，因为多人开发中使用不同版本的jar包可能会有版本的冲突问题。Maven提供一个中央仓库，里面有几乎所有主流技术的jar包，我们只需要在配置文件中指定好要使用的jar，Maven就会帮我们自动下载。Maven会在本地建一个仓库，第一次下载的jar包放在本地仓库里，Maven根据配置注入jar的时候先从本地仓库里查找，如果没有再从远程中央仓库里下载，提高了效率。 如何安装和配置Maven安装Maven跟安装Jdk差不多，我们只需要把Maven下载下来，在环境变量中新建一个变量%MAVEN_HOME%，再在path中加上%MAVEN_HOME%/bin，如此，我们就能在控制台中使用Maven的命令了，我们可以在控制台输入mvn -v，如果成功输入Maven的版本信息，就说明Maven已经能正常工作了。但是，在使用之前我们做一些简单的修改来更好的使用Maven。 一些必要的修改首先，在Maven根目录下进入conf文件夹找到settings.xml配置文件，它可以配置Maven各种信息。在文件里面找到&lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;，这一行是配置Maven本地仓库的路径，把标签中的路径换成自己指定的路径例如E:\apache-maven-3.2.3-bin\Repository，要在对应的地方把这个文件夹新建好，这样Maven下载下来的jar包就会存到这个文件夹中。注意这一行在文件中是注释掉的，要把注释打开。接着，在配置文件中找到&lt;proxies&gt;标签，这里是设置Maven的镜像，如果我们有自己局域网内的中央仓库，可以在这里设置，这样Maven就会从我们局域网中的仓库下载，速度就会快很多。在日常开发中主要是设置这两个地方。 在Eclipse中集成Maven安装Maven插件我使用的是Eclipse版本是kepler，首先要安装Maven插件，在菜单栏中选择Help——Install New Software…接着你会看到一个Install对话框，点击Work with:字段边上的Add按钮，你会得到一个新的Add Repository对话框，在Name字段中输入m2e，Location字段中输入在线安装地址，这里提供一个地址，如果失效了可以在网上再找。然后点击OK。Eclipse会下载m2eclipse安装站点上的资源信息。 加入本地Maven依次选择菜单Windows——Preferences——Maven——Installations，然后在界面中点击Add，选择本地Maven的根目录，这样我们就设置好Maven插件了。 Eclipse创建Maven项目新建项目选择Maven Project，勾选Use default Workspace location使用默认的Workspace路径，点Next，一般的Web项目我们选择webapp点Next，输入工程信息， Group Id类似一个包名，Artifact Id类似类名。其它默认即可。点Finish就完成创建了。完成后我们能在项目中找到一个pom.xml文件，里面就可以配置我们项目中所需的依赖jar包了。 最后以上就是我最近初学Maven的一点认识，Maven确实是一个很好的构建工具，而也不仅仅是一个构建工具。更深的了解还要在以后的学习当中去探索。-END-]]></content>
    </entry>

    
  
  
</search>
